<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SQL Vizualiz√©r ‚Äî Interaktivn√≠ v√Ωukov√Ω n√°stroj</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --bg: #0d1117; --bg2: #161b22; --bg3: #1c2128; --bg4: #21262d;
  --border: #30363d; --border2: #484f58;
  --text: #e6edf3; --text2: #8b949e; --text3: #6e7681;
  --blue: #58a6ff; --green: #3fb950; --yellow: #d29922;
  --purple: #bc8cff; --pink: #f778ba; --red: #ff7b72;
  --cyan: #56d4dd; --orange: #f0883e;
  --lightgreen: #7ee787; --lightred: #ffa198;
}
html, body { height: 100%; }
body { background: var(--bg); color: var(--text); font-family: 'Inter', -apple-system, sans-serif; overflow: hidden; }

/* ===== LAYOUT ===== */
.app { display: flex; flex-direction: column; height: 100vh; }
.header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 8px 20px; background: var(--bg2); border-bottom: 1px solid var(--border); flex-shrink: 0;
}
.header h1 { font-size: 15px; font-weight: 700; }
.header h1 span { color: var(--blue); }
.app-body { display: flex; flex: 1; overflow: hidden; }
.main-content { display: flex; flex: 1; overflow: hidden; }
.col-left { width: 50%; min-width: 280px; display: flex; flex-direction: column; border-right: 1px solid var(--border); }
.col-right { flex: 1; min-width: 280px; display: flex; flex-direction: column; position: relative; }

.tasks-has-check { color: var(--orange); font-size: 10px; margin-left: 4px; }

/* ===== EDITOR (compact, top-left) ===== */
.editor-section { flex: 35; min-height: 60px; display: flex; flex-direction: column; overflow: visible; position: relative; z-index: 10; }
.editor-toolbar {
  display: flex; align-items: center; justify-content: space-between;
  padding: 6px 16px; background: var(--bg2); border-bottom: 1px solid var(--border);
}
.editor-toolbar-left { display: flex; align-items: center; gap: 8px; }
.editor-toolbar-title { font-size: 11px; color: var(--text3); font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }
.editor-toolbar-right { display: flex; gap: 6px; }

.editor-wrap {
  position: relative; flex: 1; min-height: 40px; overflow: hidden; background: var(--bg);
}
.editor-line-numbers {
  position: absolute; left: 0; top: 0; width: 36px;
  padding: 10px 6px 10px 0; text-align: right;
  font-family: 'JetBrains Mono', monospace; font-size: 12px;
  line-height: 1.6; color: var(--text3); user-select: none;
  pointer-events: none; z-index: 2; overflow: hidden;
  white-space: pre;
}
.editor-highlight {
  position: absolute; top: 0; left: 0; right: 0; bottom: 0;
  padding: 10px 10px 10px 44px;
  font-family: 'JetBrains Mono', monospace; font-size: 12px;
  line-height: 1.6; white-space: pre; overflow: auto;
  pointer-events: none; z-index: 1; color: var(--text);
}
.editor-textarea {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
  padding: 10px 10px 10px 44px;
  font-family: 'JetBrains Mono', monospace; font-size: 12px;
  line-height: 1.6; color: transparent; caret-color: var(--text);
  background: transparent; border: none; outline: none; resize: none;
  white-space: pre; overflow: auto;
  z-index: 3; tab-size: 2;
}
.editor-textarea::selection { background: rgba(88,166,255,0.25); }

/* Clause order warning */
.clause-warning {
  display: none; padding: 6px 12px;
  background: rgba(255,85,85,0.12); border-top: 1px solid rgba(255,85,85,0.3);
  font-size: 12px; color: #ff5555; line-height: 1.5;
}
.clause-warning.visible { display: block; }
.clause-warning span { display: block; }

/* Syntax colors */
.syn-select { color: var(--blue); font-weight: 600; }
.syn-from { color: var(--green); font-weight: 600; }
.syn-where { color: var(--yellow); font-weight: 600; }
.syn-join { color: var(--purple); font-weight: 600; }
.syn-group { color: var(--pink); font-weight: 600; }
.syn-having { color: var(--red); font-weight: 600; }
.syn-order { color: var(--cyan); font-weight: 600; }
.syn-agg { color: var(--orange); font-weight: 600; }
.syn-string { color: var(--lightgreen); }
.syn-number { color: var(--lightred); }
.syn-operator { color: var(--text2); }
.syn-paren { color: var(--text2); }
.syn-star { color: var(--text); }
.syn-alias { color: var(--text2); font-style: italic; }
.syn-comma { color: var(--text3); }
.syn-dot { color: var(--text3); }
.syn-comment { color: var(--text3); font-style: italic; }

/* ===== BUTTONS ===== */
.btn {
  padding: 5px 12px; border-radius: 6px; border: 1px solid var(--border);
  background: var(--bg3); color: var(--text); font-size: 11px;
  font-weight: 500; cursor: pointer; transition: all 0.15s;
  display: flex; align-items: center; gap: 4px; font-family: 'Inter', sans-serif;
}
.btn:hover { background: var(--bg4); border-color: var(--border2); }
.btn-primary { background: #1f6feb; border-color: #1f6feb; color: #fff; }
.btn-primary:hover { background: #388bfd; }
.btn kbd {
  background: rgba(255,255,255,0.1); padding: 1px 4px; border-radius: 3px;
  font-size: 9px; font-family: 'JetBrains Mono', monospace;
}

/* ===== PIPELINE ===== */
.pipeline-section {
  flex: 35; display: flex; flex-direction: column; overflow: hidden;
  background: var(--bg); min-height: 100px; position: relative;
  border-bottom: 1px solid var(--border);
}
.pipeline-header {
  padding: 6px 16px; background: var(--bg2); border-bottom: 1px solid var(--border); flex-shrink: 0;
}
.pipeline-header-title { font-size: 11px; color: var(--text2); font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }

/* ===== DATAFLOW SECTION ===== */
.dataflow-section { flex: 65; min-height: 80px; display: flex; flex-direction: column; overflow: hidden; border-top: 1px solid var(--border); }
.dataflow-header {
  padding: 6px 16px; background: var(--bg2);
  border-bottom: 1px solid var(--border); flex-shrink: 0;
}
.timeline-top { display: flex; align-items: center; justify-content: space-between; }
.timeline-title { font-size: 11px; color: var(--text2); font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }
.timeline-step-label { font-size: 10px; color: var(--text3); font-weight: 500; font-family: 'JetBrains Mono', monospace; }
.timeline-controls { display: flex; align-items: center; gap: 4px; margin-top: 6px; }
.tl-btn {
  width: 22px; height: 22px; border-radius: 4px; border: 1px solid var(--border);
  background: var(--bg3); color: var(--text2); font-size: 10px; cursor: pointer;
  display: flex; align-items: center; justify-content: center; flex-shrink: 0;
  padding: 0; font-family: inherit; transition: all 0.15s;
}
.tl-btn:hover { background: var(--bg4); color: var(--text); border-color: var(--border2); }
.tl-btn.playing { color: var(--blue); border-color: var(--blue); background: rgba(88,166,255,0.1); }
.timeline-slider {
  flex: 1;
  -webkit-appearance: none; appearance: none; width: 100%; height: 4px;
  background: var(--bg4); border-radius: 2px; outline: none; cursor: pointer;
}
.timeline-slider::-webkit-slider-thumb {
  -webkit-appearance: none; appearance: none; width: 14px; height: 14px;
  background: var(--blue); border-radius: 50%; cursor: pointer; border: 2px solid var(--bg);
  box-shadow: 0 0 4px rgba(88,166,255,0.4);
}
.timeline-slider::-moz-range-thumb {
  width: 14px; height: 14px; background: var(--blue); border-radius: 50%;
  cursor: pointer; border: 2px solid var(--bg);
}
.dataflow-wrap { flex: 1; overflow: auto; padding: 12px 16px; }
.pipeline-wrap {
  flex: 1; position: relative; overflow: auto; padding: 20px 24px 10px;
}
.pipeline-tables {
  display: flex; gap: 32px; justify-content: center; align-items: flex-start;
  position: relative; min-height: 120px;
}
.pipeline-svg {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none; z-index: 1;
}
.pipeline-svg path {
  fill: none; stroke-width: 2.5; stroke-linecap: round;
}
.join-line { stroke: var(--purple); opacity: 0.8; }
.join-line-anim {
  stroke-dasharray: 8 4; animation: dashFlow 1s linear infinite;
}
@keyframes dashFlow { to { stroke-dashoffset: -12; } }
.join-dot {
  fill: var(--purple); r: 4; opacity: 0.9;
}

/* Pipeline table cards */
.p-table {
  background: var(--bg2); border: 2px solid var(--border); border-radius: 10px;
  min-width: 150px; max-width: 220px; flex: 1; position: relative; z-index: 2;
  transition: all 0.3s;
}
.p-table.hl-from { border-color: var(--green); box-shadow: 0 0 16px rgba(63,185,80,0.15); }
.p-table.hl-join { border-color: var(--purple); box-shadow: 0 0 16px rgba(188,140,255,0.15); }
.p-table-name {
  padding: 7px 12px; font-size: 13px; font-weight: 700;
  font-family: 'JetBrains Mono', monospace;
  background: var(--bg3); border-bottom: 1px solid var(--border);
  border-radius: 8px 8px 0 0; transition: all 0.3s; text-align: center;
}
.hl-from .p-table-name { background: rgba(63,185,80,0.12); color: var(--green); }
.hl-join .p-table-name { background: rgba(188,140,255,0.12); color: var(--purple); }
.p-table-cols { padding: 4px 0; }
.p-col {
  padding: 2px 12px; font-size: 11px; font-family: 'JetBrains Mono', monospace;
  color: var(--text2); transition: all 0.2s; border-left: 2px solid transparent;
  position: relative;
}
.p-col.hl-select { background: rgba(88,166,255,0.08); color: var(--blue); border-left-color: var(--blue); }
.p-col.hl-where { background: rgba(210,153,34,0.08); color: var(--yellow); border-left-color: var(--yellow); }
.p-col.hl-join-col { background: rgba(188,140,255,0.08); color: var(--purple); border-left-color: var(--purple); }
.p-col.hl-group { background: rgba(247,120,186,0.08); color: var(--pink); border-left-color: var(--pink); }
.p-col.hl-having { background: rgba(255,123,114,0.08); color: var(--red); border-left-color: var(--red); }
.p-col.hl-order { background: rgba(86,212,221,0.08); color: var(--cyan); border-left-color: var(--cyan); }
.p-col-pk { color: var(--orange); }

/* ===== EXECUTION FLOW ===== */
.flow-bar {
  display: flex; gap: 4px; padding: 10px 24px; align-items: center;
  flex-shrink: 0; flex-wrap: wrap; background: var(--bg2);
  border-top: 1px solid var(--border);
}
.flow-label { font-size: 10px; color: var(--text3); margin-right: 4px; text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600; }
.flow-arrow { color: var(--text3); font-size: 10px; margin: 0 2px; }
.flow-step {
  padding: 4px 10px; border-radius: 6px; font-size: 11px; font-weight: 600;
  background: var(--bg3); color: var(--text3); border: 1px solid var(--border);
  transition: all 0.3s; cursor: pointer; position: relative;
}
.flow-step.active { border-color: currentColor; }
.flow-step.s-from.active { color: var(--green); background: rgba(63,185,80,0.1); }
.flow-step.s-join.active { color: var(--purple); background: rgba(188,140,255,0.1); }
.flow-step.s-where.active { color: var(--yellow); background: rgba(210,153,34,0.1); }
.flow-step.s-group.active { color: var(--pink); background: rgba(247,120,186,0.1); }
.flow-step.s-having.active { color: var(--red); background: rgba(255,123,114,0.1); }
.flow-step.s-select.active { color: var(--blue); background: rgba(88,166,255,0.1); }
.flow-step.s-order.active { color: var(--cyan); background: rgba(86,212,221,0.1); }

/* Step tooltip */
.flow-tooltip {
  display: none; position: absolute; bottom: calc(100% + 8px); left: 50%;
  transform: translateX(-50%); background: var(--bg3); border: 1px solid var(--border);
  border-radius: 8px; padding: 8px 12px; font-size: 11px; font-weight: 400;
  color: var(--text); white-space: nowrap; z-index: 100;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4); line-height: 1.4;
}
.flow-tooltip::after {
  content:''; position:absolute; top:100%; left:50%; transform:translateX(-50%);
  border:5px solid transparent; border-top-color:var(--border);
}
.flow-step.show-tip .flow-tooltip { display: block; }

/* ===== RESULTS ===== */
.results-section {
  flex: 65; min-height: 80px;
  display: flex; flex-direction: column; overflow: hidden;
}
.results-header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 6px 16px; background: var(--bg2); border-bottom: 1px solid var(--border); flex-shrink: 0;
}
.results-header-title { font-size: 11px; color: var(--text2); font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }
.results-status { font-size: 11px; color: var(--text3); display: flex; gap: 12px; }
.results-status span { display: flex; align-items: center; gap: 4px; }
.results-wrap { flex: 1; overflow: auto; }
.results-table { width: 100%; border-collapse: collapse; font-size: 12px; font-family: 'JetBrains Mono', monospace; }
.results-table th {
  padding: 6px 12px; text-align: left; font-weight: 600;
  background: var(--bg3); border-bottom: 2px solid var(--border);
  color: var(--blue); position: sticky; top: 0; z-index: 1; white-space: nowrap;
}
.results-table td { padding: 5px 12px; border-bottom: 1px solid var(--border); white-space: nowrap; }
.results-table tbody tr:hover { background: var(--bg3); }
.results-table .cell-null { color: var(--text3); font-style: italic; }
.results-table .cell-number { color: var(--lightred); }
.results-table .cell-string { color: var(--text); }
.results-table .row-animate { animation: rowFadeIn 0.3s ease forwards; opacity: 0; }
@keyframes rowFadeIn { from { opacity:0; transform:translateY(4px); } to { opacity:1; transform:translateY(0); } }
.results-error { padding: 16px; color: var(--red); font-size: 12px; font-family: 'JetBrains Mono', monospace; line-height: 1.5; background: rgba(255,123,114,0.05); border-radius: 8px; margin: 12px; }
.results-empty { padding: 30px; text-align: center; color: var(--text3); font-size: 12px; }
.results-empty kbd { background: var(--bg3); padding: 2px 6px; border-radius: 4px; border: 1px solid var(--border); font-family: 'JetBrains Mono', monospace; font-size: 10px; }

/* ===== EXAMPLES ===== */
.examples-dropdown { position: relative; display: inline-block; }
.examples-menu {
  display: none; position: absolute; top: calc(100% + 4px); right: 0;
  background: var(--bg3); border: 1px solid var(--border); border-radius: 8px;
  min-width: 380px; max-height: 380px; overflow: auto; z-index: 200;
  box-shadow: 0 8px 24px rgba(0,0,0,0.5);
}
.examples-menu.show { display: block; }
.example-item {
  padding: 7px 12px; cursor: pointer; font-size: 11px;
  border-bottom: 1px solid var(--border); transition: background 0.1s;
  display: flex; gap: 6px; align-items: flex-start;
}
.example-item:last-child { border-bottom: none; }
.example-item:hover { background: var(--bg4); }
.example-num { color: var(--text3); font-weight: 600; font-size: 10px; min-width: 18px; font-family: 'JetBrains Mono', monospace; }
.example-info { flex: 1; }
.example-name { color: var(--text); font-weight: 500; margin-bottom: 1px; font-size: 11px; }
.example-sql { color: var(--text3); font-size: 10px; font-family: 'JetBrains Mono', monospace; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 320px; }

/* ===== DATA FLOW ===== */
#dataFlow { padding: 0; }
#dataFlow:empty { display: none; }
.df-card {
  margin-bottom: 12px; border-radius: 8px; border: 1px solid var(--border);
  background: var(--bg2); overflow: hidden;
}
.df-card-header {
  display: flex; align-items: center; gap: 8px; padding: 6px 12px;
  font-size: 10px; font-weight: 600; border-bottom: 1px solid var(--border);
  font-family: 'JetBrains Mono', monospace; line-height: 1.4;
}
.df-card-header > span:nth-child(2) { flex: 1; min-width: 0; word-break: break-word; }
.df-card-header .df-step-num {
  width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center;
  justify-content: center; font-size: 10px; font-weight: 700; flex-shrink: 0;
}
.df-card-header .df-count {
  margin-left: auto; font-weight: 400; color: var(--text3); font-size: 10px;
}
.df-card-body { display: flex; gap: 6px; padding: 6px; }
.df-card-body.df-single { display: block; }
.df-half { flex: 1; min-width: 0; }
.df-half-label { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text3); margin-bottom: 4px; padding: 0 4px; }
.df-mini-table { width: 100%; border-collapse: collapse; font-size: 10px; font-family: 'JetBrains Mono', monospace; }
.df-mini-table th { padding: 2px 5px; text-align: left; font-weight: 600; color: var(--text2); border-bottom: 1px solid var(--border); white-space: nowrap; font-size: 9px; }
.df-mini-table td { padding: 2px 5px; white-space: nowrap; color: var(--text2); border-bottom: 1px solid rgba(48,54,61,0.5); }
.df-mini-table tr.df-pass td { color: var(--green); }
.df-mini-table tr.df-fail td { color: var(--text3); text-decoration: line-through; opacity: 0.6; }
.df-mini-table .df-null { color: var(--text3); font-style: italic; }
.df-mini-table .df-more { color: var(--text3); font-style: italic; font-size: 9px; }
.df-mini-table .df-new-col { color: var(--purple); }
.df-arrow { text-align: center; color: var(--text3); font-size: 14px; padding: 4px 0; }
/* Step colors */
.df-from .df-step-num { background: rgba(63,185,80,0.2); color: var(--green); }
.df-from .df-card-header { color: var(--green); }
.df-join .df-step-num { background: rgba(188,140,255,0.2); color: var(--purple); }
.df-join .df-card-header { color: var(--purple); }
.df-where .df-step-num { background: rgba(210,153,34,0.2); color: var(--yellow); }
.df-where .df-card-header { color: var(--yellow); }
.df-group .df-step-num { background: rgba(247,120,186,0.2); color: var(--pink); }
.df-group .df-card-header { color: var(--pink); }
.df-having .df-step-num { background: rgba(255,123,114,0.2); color: var(--red); }
.df-having .df-card-header { color: var(--red); }
.df-select .df-step-num { background: rgba(88,166,255,0.2); color: var(--blue); }
.df-select .df-card-header { color: var(--blue); }
.df-order .df-step-num { background: rgba(86,212,221,0.2); color: var(--cyan); }
.df-order .df-card-header { color: var(--cyan); }
.df-setop .df-step-num { background: rgba(210,153,34,0.2); color: var(--yellow); }
.df-setop .df-card-header { color: var(--yellow); }
.df-case .df-step-num { background: rgba(188,140,255,0.2); color: var(--purple); }
.df-case .df-card-header { color: var(--purple); }
.df-case-table { width: 100%; border-collapse: collapse; font-size: 10px; font-family: 'JetBrains Mono', monospace; }
.df-case-table th { padding: 2px 5px; text-align: left; font-weight: 600; color: var(--text2); border-bottom: 1px solid var(--border); white-space: nowrap; font-size: 9px; }
.df-case-table td { padding: 2px 5px; white-space: nowrap; color: var(--text2); border-bottom: 1px solid rgba(48,54,61,0.5); }
.df-case-table tr.df-case-match td { color: var(--green); }
.df-case-table tr.df-case-skip td { color: var(--text3); opacity: 0.5; }
.df-case-table .df-case-result { font-weight: 600; }
.df-setop-parts { display: flex; flex-direction: column; gap: 8px; padding: 6px; }
.df-setop-part { border: 1px solid var(--border); border-radius: 4px; padding: 4px; }
.df-setop-part-label { font-size: 9px; font-weight: 600; color: var(--text3); margin-bottom: 4px; padding: 0 4px; }

/* ===== SCROLLBAR ===== */
::-webkit-scrollbar { width: 6px; height: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--bg4); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: var(--border2); }

/* ===== TASKS PANEL ===== */
.btn-tasks { background: rgba(240,136,62,0.15); border-color: var(--orange); color: var(--orange); }
.btn-tasks:hover { background: rgba(240,136,62,0.3); }
.btn-tasks.active { background: var(--orange); color: var(--bg); }

.tasks-overlay {
  display: none; position: fixed; inset: 0; z-index: 900;
  background: rgba(0,0,0,0.4);
}
.tasks-overlay.show { display: block; }

.tasks-panel {
  position: fixed; top: 0; right: -400px; width: 380px; height: 100vh;
  background: var(--bg2); border-left: 2px solid var(--orange);
  z-index: 901; display: flex; flex-direction: column;
  transition: right 0.28s cubic-bezier(0.4,0,0.2,1);
  box-shadow: -4px 0 24px rgba(0,0,0,0.5);
}
.tasks-panel.open { right: 0; }

.tasks-header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 10px 14px; border-bottom: 1px solid var(--border); flex-shrink: 0;
  background: var(--bg3);
}
.tasks-title { font-size: 13px; font-weight: 700; color: var(--orange); }
.tasks-upload-btn {
  padding: 4px 10px; border-radius: 5px; border: 1px solid var(--border);
  background: var(--bg4); color: var(--text2); font-size: 11px;
  cursor: pointer; transition: all 0.15s; font-family: 'Inter', sans-serif;
}
.tasks-upload-btn:hover { background: var(--bg); color: var(--text); border-color: var(--border2); }
.tasks-paste-btn {
  padding: 4px 10px; border-radius: 5px; border: 1px solid var(--border);
  background: var(--bg4); color: var(--text2); font-size: 11px;
  cursor: pointer; transition: all 0.15s; font-family: 'Inter', sans-serif;
}
.tasks-paste-btn:hover { background: var(--bg); color: var(--text); border-color: var(--border2); }
.tasks-close-btn {
  background: none; border: none; color: var(--text3); cursor: pointer;
  font-size: 16px; padding: 2px 6px; border-radius: 4px;
}
.tasks-close-btn:hover { color: var(--text); background: var(--bg4); }

.tasks-pin-btn {
  background: none; border: 1px solid var(--border); color: var(--text3);
  cursor: pointer; font-size: 13px; padding: 2px 7px; border-radius: 4px;
  transition: all 0.15s; font-family: inherit;
}
.tasks-pin-btn:hover { background: var(--bg4); color: var(--text); border-color: var(--border2); }
.tasks-pin-btn.pinned { background: rgba(240,136,62,0.2); border-color: var(--orange); color: var(--orange); }

/* Docked mode: panel sits inline to the right of main content */
.app.tasks-docked .tasks-panel {
  position: relative; right: auto; top: auto; height: 100%;
  width: 320px; flex-shrink: 0;
  box-shadow: none;
  border-left: 2px solid var(--orange);
  transition: none;
}
.app.tasks-docked .tasks-overlay { display: none !important; }
.app.tasks-docked .main-content { margin-right: 0; flex: 1; min-width: 0; }

/* Wrapper for docked layout */
.app-body { display: flex; flex: 1; overflow: hidden; }

/* Record bar */
.tasks-record-bar {
  padding: 8px 14px 10px; border-bottom: 1px solid var(--border);
  background: rgba(240,136,62,0.05); flex-shrink: 0;
}
.tasks-record-task-label {
  font-size: 10px; color: var(--text3); line-height: 1.5; display: block;
}
.tasks-record-task-label b { color: var(--orange); }
.tasks-record-btn {
  padding: 3px 9px; border-radius: 5px; border: 1px solid var(--border);
  background: var(--bg4); color: var(--text2); font-size: 10px;
  cursor: pointer; transition: all 0.15s; font-family: 'Inter', sans-serif;
}
.tasks-record-btn:hover { background: rgba(240,136,62,0.15); border-color: var(--orange); color: var(--orange); }
.tasks-clear-btn:hover { background: rgba(255,123,114,0.15); border-color: var(--red); color: var(--red); }
.tasks-solution-badge {
  font-size: 10px; color: var(--yellow); background: rgba(210,153,34,0.1);
  border: 1px solid rgba(210,153,34,0.3); border-radius: 4px;
  padding: 2px 7px; display: inline-flex; align-items: center;
}
.app.tasks-docked .app-body { flex-direction: row; }

.tasks-body { flex: 1; overflow-y: auto; padding: 8px 0; }
.tasks-empty-state { padding: 40px 20px; text-align: center; }

.tasks-chapter {
  margin-bottom: 2px;
}
.tasks-chapter-header {
  padding: 8px 14px 6px; font-size: 11px; font-weight: 700;
  color: var(--orange); text-transform: uppercase; letter-spacing: 0.5px;
  background: rgba(240,136,62,0.07); border-top: 1px solid rgba(240,136,62,0.2);
  cursor: pointer; display: flex; align-items: center; gap: 6px;
  user-select: none;
}
.tasks-chapter-header:hover { background: rgba(240,136,62,0.12); }
.tasks-chapter-toggle { font-size: 9px; color: var(--text3); transition: transform 0.2s; }
.tasks-chapter.collapsed .tasks-chapter-toggle { transform: rotate(-90deg); }
.tasks-chapter-count { margin-left: auto; font-size: 10px; color: var(--text3); font-weight: 400; }
.tasks-chapter.collapsed .tasks-task-list { display: none; }

.tasks-task-list { padding: 2px 0; }

.tasks-task {
  display: flex; align-items: flex-start; gap: 10px;
  padding: 7px 14px; cursor: pointer; transition: background 0.12s;
  border-left: 3px solid transparent; position: relative;
}
.tasks-task:hover { background: var(--bg3); }
.tasks-task.active { background: rgba(88,166,255,0.07); border-left-color: var(--blue); }
.tasks-task.solved { border-left-color: var(--green); }
.tasks-task.solved .tasks-task-num { color: var(--green); }

.tasks-task-num {
  font-size: 11px; font-weight: 700; font-family: 'JetBrains Mono', monospace;
  color: var(--text3); min-width: 24px; flex-shrink: 0; padding-top: 1px;
}
.tasks-task-text {
  font-size: 11px; color: var(--text2); line-height: 1.5; flex: 1;
}
.tasks-task.active .tasks-task-text { color: var(--text); }
.tasks-task-check {
  width: 16px; height: 16px; border-radius: 50%; border: 2px solid var(--border2);
  flex-shrink: 0; margin-top: 1px; display: flex; align-items: center;
  justify-content: center; font-size: 9px; transition: all 0.2s;
}
.tasks-task.solved .tasks-task-check {
  background: var(--green); border-color: var(--green); color: var(--bg);
}

.tasks-footer {
  padding: 10px 14px; border-top: 1px solid var(--border);
  background: var(--bg3); flex-shrink: 0;
}
.tasks-progress-label { font-size: 10px; color: var(--text3); display: block; margin-bottom: 5px; }
.tasks-progress-bar { height: 4px; background: var(--bg4); border-radius: 2px; overflow: hidden; }
.tasks-progress-fill { height: 100%; background: var(--green); border-radius: 2px; transition: width 0.4s ease; width: 0%; }

/* PASTE MODAL */
.paste-modal-overlay {
  position: fixed; inset: 0; z-index: 1000;
  background: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center;
}
.paste-modal {
  background: var(--bg2); border: 1px solid var(--border); border-radius: 10px;
  width: 520px; max-width: 95vw; display: flex; flex-direction: column;
  box-shadow: 0 12px 40px rgba(0,0,0,0.6);
}
.paste-modal-header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 12px 16px; border-bottom: 1px solid var(--border);
}
.paste-modal-textarea {
  flex: 1; min-height: 280px; padding: 12px 14px;
  font-family: 'JetBrains Mono', monospace; font-size: 11px;
  background: var(--bg); color: var(--text); border: none; outline: none;
  resize: vertical; line-height: 1.6;
}
.paste-modal-footer {
  display: flex; justify-content: flex-end; gap: 8px;
  padding: 10px 14px; border-top: 1px solid var(--border);
}

/* ===== JOIN VENN DIAGRAM ===== */
.df-join-venn {
  padding: 8px 12px 4px; display: flex; flex-direction: column; align-items: center; gap: 6px;
}
.df-join-venn-svg { width: 140px; height: 70px; }
.df-join-type-badge {
  font-size: 10px; font-weight: 700; font-family: 'JetBrains Mono', monospace;
  padding: 2px 8px; border-radius: 4px; letter-spacing: 0.5px;
  background: rgba(188,140,255,0.15); color: var(--purple);
}
.df-join-desc { font-size: 10px; color: var(--text3); text-align: center; line-height: 1.4; }

/* ===== RESIZE ===== */
.resize-h {
  height: 4px; cursor: row-resize; background: transparent; flex-shrink: 0;
  transition: background 0.15s; z-index: 10;
}
.resize-h:hover, .resize-h.dragging { background: var(--blue); }
.resize-v {
  width: 4px; cursor: col-resize; background: transparent; flex-shrink: 0;
  transition: background 0.15s; z-index: 10;
}
.resize-v:hover, .resize-v.dragging { background: var(--blue); }

/* ===== CHALLENGE MODE ===== */
.btn-challenge { background: rgba(210,153,34,0.15); border-color: var(--yellow); color: var(--yellow); }
.btn-challenge:hover { background: rgba(210,153,34,0.3); }
.btn-challenge.active { background: var(--yellow); color: var(--bg); }

.challenge-panel {
  background: var(--bg2); border-bottom: 2px solid var(--yellow);
  padding: 12px 16px; flex-shrink: 0;
  animation: ch-slide 0.2s ease-out;
}
@keyframes ch-slide { from { opacity: 0; transform: translateY(-8px); } to { opacity: 1; transform: translateY(0); } }
.challenge-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px; }
.challenge-tag {
  font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px;
  color: var(--yellow); background: rgba(210,153,34,0.15); padding: 2px 8px; border-radius: 4px;
}
.challenge-close {
  background: none; border: none; color: var(--text3); cursor: pointer; font-size: 14px; padding: 2px 6px;
}
.challenge-close:hover { color: var(--text); }
.challenge-from { font-size: 11px; color: var(--yellow); font-weight: 600; margin-bottom: 6px; }
.challenge-body { font-size: 12px; color: var(--text); line-height: 1.6; margin-bottom: 8px; }
.challenge-hint { font-size: 10px; color: var(--text3); font-style: italic; }
.challenge-nav {
  display: flex; align-items: center; justify-content: space-between; margin-top: 10px;
  padding-top: 8px; border-top: 1px solid var(--border);
}
.ch-nav-btn {
  background: var(--bg3); border: 1px solid var(--border); color: var(--text2);
  padding: 3px 10px; border-radius: 4px; font-size: 10px; cursor: pointer; font-family: 'Inter', sans-serif;
}
.ch-nav-btn:hover { background: var(--bg4); color: var(--text); }
.ch-nav-btn:disabled { opacity: 0.3; cursor: default; }
.challenge-counter { font-size: 10px; color: var(--text3); }
.challenge-done { color: var(--green); font-size: 10px; margin-left: 6px; }

.challenge-result {
  margin-top: 8px; padding: 8px 12px; border-radius: 6px; text-align: center;
  font-weight: 600; font-size: 12px; font-family: 'Inter', sans-serif;
  animation: ch-slide 0.2s ease-out;
}
.challenge-result.success { background: rgba(63,185,80,0.15); color: var(--green); border: 1px solid rgba(63,185,80,0.4); }
.challenge-result.fail { background: rgba(255,123,114,0.1); color: var(--red); border: 1px solid rgba(255,123,114,0.3); }

@keyframes ch-shake { 0%,100% { transform: translateX(0); } 25% { transform: translateX(-4px); } 75% { transform: translateX(4px); } }
.challenge-result.fail { animation: ch-shake 0.3s ease-out; }

.challenge-flash { position: fixed; inset: 0; pointer-events: none; z-index: 9999; animation: ch-flash 0.7s forwards; }
@keyframes ch-flash { 0% { background: rgba(63,185,80,0.25); } 100% { background: rgba(63,185,80,0); } }

.confetti-piece {
  position: fixed; width: 8px; height: 8px; top: -10px; z-index: 10000;
  border-radius: 2px; pointer-events: none;
  animation: confetti-fall 1.8s ease-in forwards;
}
@keyframes confetti-fall {
  0% { transform: translateY(0) rotate(0deg); opacity: 1; }
  100% { transform: translateY(105vh) rotate(720deg); opacity: 0; }
}

/* ===== DICTIONARY PANEL ===== */
.btn-dict { background: rgba(86,212,221,0.15); border-color: var(--cyan); color: var(--cyan); }
.btn-dict:hover { background: rgba(86,212,221,0.3); }
.btn-dict.active { background: var(--cyan); color: var(--bg); }

.dict-panel {
  position: absolute; top: 0; right: 0; bottom: 0; width: 300px;
  background: var(--bg2); border-left: 2px solid var(--cyan); z-index: 30;
  display: flex; flex-direction: column; animation: dict-slide 0.2s ease-out;
}
@keyframes dict-slide { from { transform: translateX(100%); } to { transform: translateX(0); } }
.dict-header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 10px 14px; border-bottom: 1px solid var(--border); flex-shrink: 0;
}
.dict-header-title { font-size: 12px; font-weight: 700; color: var(--cyan); text-transform: uppercase; letter-spacing: 0.5px; }
.dict-close { background: none; border: none; color: var(--text3); cursor: pointer; font-size: 14px; padding: 2px 6px; }
.dict-close:hover { color: var(--text); }
.dict-list { flex: 1; overflow-y: auto; padding: 8px 0; }
.dict-item { padding: 8px 14px; border-bottom: 1px solid rgba(48,54,61,0.5); }
.dict-item:hover { background: var(--bg3); }
.dict-kw { display: flex; align-items: center; gap: 8px; margin-bottom: 3px; }
.dict-tag {
  font-size: 10px; font-weight: 700; font-family: 'JetBrains Mono', monospace;
  padding: 1px 6px; border-radius: 3px; white-space: nowrap;
}
.dict-tag-blue { background: rgba(88,166,255,0.15); color: var(--blue); }
.dict-tag-green { background: rgba(63,185,80,0.15); color: var(--green); }
.dict-tag-yellow { background: rgba(210,153,34,0.15); color: var(--yellow); }
.dict-tag-purple { background: rgba(188,140,255,0.15); color: var(--purple); }
.dict-tag-orange { background: rgba(240,136,62,0.15); color: var(--orange); }
.dict-tag-pink { background: rgba(247,120,186,0.15); color: var(--pink); }
.dict-tag-cyan { background: rgba(86,212,221,0.15); color: var(--cyan); }
.dict-tag-red { background: rgba(255,123,114,0.15); color: var(--red); }
.dict-desc { font-size: 11px; color: var(--text2); line-height: 1.4; }
.dict-example { font-size: 10px; color: var(--text3); font-family: 'JetBrains Mono', monospace; margin-top: 3px; }

/* ===== MOBILE ===== */
@media (max-width: 768px) {
  body { overflow: auto; }
  .app { height: auto; min-height: 100vh; }
  .main-content { flex-direction: column; overflow: visible; }
  .col-left, .col-right { display: contents; }
  .resize-v, .resize-h { display: none !important; }

  /* Po≈ôad√≠: Editor ‚Üí V√Ωsledky ‚Üí Pr≈Øbƒõh ‚Üí Vizualizace */
  .editor-section { order: 1; flex: none !important; height: 200px; border-bottom: 2px solid var(--border2); }
  .results-section { order: 2; flex: none !important; border-bottom: 2px solid var(--border2); }
  .dataflow-section { order: 3; flex: none !important; border-bottom: 2px solid var(--border2); }
  .pipeline-section { order: 4; flex: none !important; }

  /* V√Ωsledky omezen√©, pr≈Øbƒõh + vizualizace rostou podle obsahu */
  .results-wrap { max-height: 50vh; }
  .dataflow-wrap { max-height: none; overflow: visible; }
  .pipeline-wrap { overflow: visible; padding: 12px; }
  .pipeline-tables { flex-direction: column; align-items: stretch; gap: 24px; }
  .p-table { max-width: none; min-width: 0; }

  /* Toolbar na men≈°√≠ obrazovce */
  .header { padding: 6px 12px; }
  .header h1 { font-size: 13px; }
  .editor-toolbar { flex-wrap: wrap; gap: 6px; padding: 6px 10px; }
  .editor-toolbar-right { flex-wrap: wrap; }
  .btn { font-size: 10px; padding: 4px 8px; }
  .btn kbd { display: none; }

  /* P≈ô√≠klady menu ‚Äî fixn√≠ overlay p≈ôes celou ≈°√≠≈ôku */
  .examples-dropdown { position: static; }
  .examples-menu {
    position: fixed; top: auto; bottom: 0; left: 8px; right: 8px;
    min-width: 0; max-height: 60vh; border-radius: 12px 12px 0 0;
    box-shadow: 0 -8px 32px rgba(0,0,0,0.6);
  }
  .example-sql { white-space: normal; overflow: visible; max-width: none; font-size: 9px; }

  /* Zabr√°nit zoomu p≈ôi focusu na textarea (iOS) */
  .editor-textarea { font-size: 16px; }
  .editor-highlight { font-size: 16px; }
  .editor-line-numbers { font-size: 16px; }

  /* Flow bar wrap */
  .flow-bar { padding: 8px 12px; flex-wrap: wrap; }

  /* Pipeline SVG ‚Äî vertik√°ln√≠ ƒç√°ry mezi tabulkami */
  .pipeline-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
  .pipeline-tables { position: relative; }

  /* Challenge panel */
  .challenge-panel { padding: 10px 12px; }
  .challenge-body { font-size: 11px; }
  .ch-nav-btn { font-size: 9px; padding: 3px 8px; }

  /* Dictionary panel */
  .dict-panel { position: fixed; top: 0; left: 0; right: 0; bottom: 0; width: 100%; border-left: none; border-top: 2px solid var(--cyan); }
}
</style>
</head>
<body>
<div class="app">
  <div class="header">
    <h1><span>SQL</span> Vizualiz√©r</h1>
    <div style="display:flex;align-items:center;gap:8px">
      <span style="font-size:11px;color:var(--text3)">4IT218 ‚Äî Oracle SQL</span>
      <button class="btn btn-dict" id="btnDict" onclick="toggleDict()">Slovn√≠k</button>
      <button class="btn btn-tasks" id="btnTasks" onclick="toggleTasksPanel()">üìã √ökoly</button>
    </div>
  </div>

  <div class="app-body" id="appBody">
  <div class="main-content">
    <!-- LEV√ù SLOUPEC -->
    <div class="col-left" id="colLeft">
      <div class="editor-section" id="editorSection">
        <div class="editor-toolbar">
          <div class="editor-toolbar-left">
            <span class="editor-toolbar-title">SQL Editor</span>
          </div>
          <div class="editor-toolbar-right">
            <div class="examples-dropdown">
              <button class="btn" id="btnExamples" onclick="toggleExamples()">P≈ô√≠klady ‚ñæ</button>
              <div class="examples-menu" id="examplesMenu"></div>
            </div>
            <button class="btn btn-challenge" id="btnChallenge" onclick="toggleChallenge()">Challenge</button>
            <button class="btn btn-primary" id="btnRun" onclick="executeQuery()">‚ñ∂ Spustit <kbd>Ctrl+Enter</kbd></button>
          </div>
        </div>
        <div class="editor-wrap" id="editorWrap">
          <div class="editor-line-numbers" id="lineNumbers">1</div>
          <div class="editor-highlight" id="editorHighlight"></div>
          <textarea class="editor-textarea" id="editorTextarea" spellcheck="false" placeholder="Napi≈° SQL dotaz..."></textarea>
        </div>
        <div class="clause-warning" id="clauseWarning"></div>
      </div>
      <div class="challenge-panel" id="challengePanel" style="display:none">
        <div class="challenge-card">
          <div class="challenge-header">
            <span class="challenge-tag" id="challengeTag">CHALLENGE #1</span>
            <button class="challenge-close" onclick="closeChallenge()" title="Zav≈ô√≠t">‚úï</button>
          </div>
          <div class="challenge-from" id="challengeFrom"></div>
          <div class="challenge-body" id="challengeBody"></div>
          <div class="challenge-hint" id="challengeHint"></div>
          <div class="challenge-nav">
            <button class="ch-nav-btn" id="chPrev" onclick="prevChallenge()">‚Üê P≈ôedchoz√≠</button>
            <span class="challenge-counter" id="challengeCounter"></span>
            <button class="ch-nav-btn" id="chNext" onclick="nextChallenge()">Dal≈°√≠ ‚Üí</button>
          </div>
        </div>
        <div class="challenge-result" id="challengeResult" style="display:none"></div>
      </div>
      <div class="resize-h" id="resizeEditorFlow"></div>
      <div class="dataflow-section" id="dataflowSection">
        <div class="dataflow-header">
          <div class="timeline-top">
            <span class="timeline-title">Pr≈Øbƒõh zpracov√°n√≠</span>
            <span class="timeline-step-label" id="timelineLabel"></span>
          </div>
          <div class="timeline-controls" id="timelineControls" style="display:none">
            <button class="tl-btn" id="tlPrev" title="P≈ôedchoz√≠ krok">‚óÄ</button>
            <button class="tl-btn" id="tlPlay" title="P≈ôehr√°t/Pozastavit">‚ñ∂</button>
            <button class="tl-btn" id="tlNext" title="Dal≈°√≠ krok">‚ñ∂</button>
            <input type="range" class="timeline-slider" id="timelineSlider" min="0" max="0" value="0">
          </div>
        </div>
        <div class="dataflow-wrap" id="dataFlow"></div>
      </div>
    </div>

    <!-- RESIZE mezi sloupci -->
    <div class="resize-v" id="resizeColumns"></div>

    <!-- PRAV√ù SLOUPEC -->
    <div class="col-right" id="colRight">
      <div class="dict-panel" id="dictPanel" style="display:none">
        <div class="dict-header">
          <span class="dict-header-title">SQL Slovn√≠k</span>
          <button class="dict-close" onclick="toggleDict()" title="Zav≈ô√≠t">‚úï</button>
        </div>
        <div class="dict-list" id="dictList"></div>
      </div>
      <div class="pipeline-section" id="pipelineSection">
        <div class="pipeline-header"><span class="pipeline-header-title">Vizualizace tabulek</span></div>
        <div class="pipeline-wrap" id="pipelineWrap">
          <div class="pipeline-tables" id="pipelineTables">
            <svg class="pipeline-svg" id="pipelineSvg"></svg>
          </div>
        </div>
        <div class="flow-bar" id="flowBar">
          <span class="flow-label">Po≈ôad√≠ vykon√°n√≠:</span>
        </div>
      </div>
      <div class="resize-h" id="resizePipelineResults"></div>
      <div class="results-section" id="resultsSection">
        <div class="results-header">
          <span class="results-header-title">V√Ωsledky</span>
          <div class="results-status" id="resultsStatus"></div>
        </div>
        <div class="results-wrap" id="resultsWrap">
          <div class="results-empty" id="resultsPlaceholder">Napi≈° SQL dotaz a stiskni <kbd>Ctrl+Enter</kbd> pro spu≈°tƒõn√≠</div>
        </div>
      </div>
    </div>
  </div>
  <!-- tasks panel docked slot -->
  </div><!-- /app-body -->
</div><!-- /app -->

<!-- TASKS PANEL (overlay by default, moves inside app-body when docked) -->
<div class="tasks-overlay" id="tasksOverlay" onclick="tasksOverlayClick()"></div>
<div class="tasks-panel" id="tasksPanel">
  <div class="tasks-header">
    <span class="tasks-title">üìã Cviƒçen√≠</span>
    <div style="display:flex;gap:5px;align-items:center">
      <label class="tasks-upload-btn" title="Nahr√°t soubor">
        <input type="file" id="tasksFileInput" accept=".txt,.ini,.md" style="display:none" onchange="handleTasksFile(event)">
        üìÇ Nahr√°t
      </label>
      <button class="tasks-paste-btn" onclick="showTasksPasteModal()">üìã Vlo≈æit text</button>
      <button class="tasks-pin-btn" id="tasksPinBtn" onclick="toggleTasksDocked()" title="P≈ôichytit panel (panel z≈Østane otev≈ôen√Ω vedle editoru)">üìå</button>
      <button class="tasks-close-btn" onclick="toggleTasksPanel()">‚úï</button>
    </div>
  </div>
  <div class="tasks-body" id="tasksBody">
    <div class="tasks-empty-state">
      <div style="font-size:32px;margin-bottom:12px">üìÑ</div>
      <div style="font-weight:600;margin-bottom:6px;color:var(--text2)">≈Ω√°dn√° cviƒçen√≠</div>
      <div style="font-size:11px;color:var(--text3);line-height:1.6">Nahraj textov√Ω soubor nebo vlo≈æ text se cviƒçen√≠mi.<br>Form√°t: ƒç√≠slo + teƒçka + text √∫kolu.<br>Kapitoly: "4.1 N√°zev kapitoly"</div>
    </div>
  </div>
  <div class="tasks-footer" id="tasksFooter" style="display:none">
    <span class="tasks-progress-label" id="tasksProgressLabel">0 / 0 splnƒõno</span>
    <div class="tasks-progress-bar"><div class="tasks-progress-fill" id="tasksProgressFill"></div></div>
  </div>
</div>

<!-- PASTE MODAL -->
<div class="paste-modal-overlay" id="pasteModalOverlay" style="display:none">
  <div class="paste-modal">
    <div class="paste-modal-header">
      <span style="font-weight:700;font-size:13px">Vlo≈æit text cviƒçen√≠</span>
      <button onclick="hideTasksPasteModal()" style="background:none;border:none;color:var(--text3);font-size:16px;cursor:pointer">‚úï</button>
    </div>
    <div style="padding:8px 14px 0;font-size:11px;color:var(--text3);line-height:1.6;border-bottom:1px solid var(--border);padding-bottom:8px;">
      Vlo≈æ text cviƒçen√≠. Ka≈æd√Ω √∫kol na nov√©m ≈ô√°dku: <code style="background:var(--bg3);padding:1px 4px;border-radius:3px;">1. Text √∫kolu</code><br>
      Kapitoly: <code style="background:var(--bg3);padding:1px 4px;border-radius:3px;">4.1 N√°zev kapitoly</code> ‚Äî volitelnƒõ p≈ôidej vzorov√© SQL za svisl√≠tkem: <code style="background:var(--bg3);padding:1px 4px;border-radius:3px;">1. Text | SELECT jmeno FROM zam</code>
    </div>
    <textarea id="pasteModalText" class="paste-modal-textarea" placeholder="Sem vlo≈æ text cviƒçen√≠...&#10;&#10;P≈ô√≠klad:&#10;4.1  Klausule SELECT&#10;&#10;1.  Vypi≈°te jm√©na zamƒõstnanc≈Ø. | SELECT jmeno FROM zam&#10;2.  Jak√© tituly se vyskytuj√≠? | SELECT DISTINCT titul FROM zam WHERE titul IS NOT NULL"></textarea>
    <div class="paste-modal-footer">
      <button class="btn" onclick="hideTasksPasteModal()">Zru≈°it</button>
      <button class="btn btn-primary" onclick="loadTasksFromPaste()">Naƒç√≠st</button>
    </div>
  </div>
</div>

<script>
// Timeline state (declared early so updatePipeline can reference)
var timelineSteps = [];
var timelinePos = 0;

// ============================================================
// DATABASE DATA
// ============================================================
const DB = {
  ODDEL: {
    columns: ['CIS_ODD','NAZEV','SEF'],
    pk: 'CIS_ODD',
    rows: [
      {CIS_ODD:1, NAZEV:'PROJEKCE', SEF:6},
      {CIS_ODD:2, NAZEV:'KNIHOVNA', SEF:12},
      {CIS_ODD:3, NAZEV:'PROGRAMOVANI', SEF:20},
      {CIS_ODD:4, NAZEV:'BUFET', SEF:31},
      {CIS_ODD:6, NAZEV:'SKLAD', SEF:41},
      {CIS_ODD:7, NAZEV:'STB', SEF:null},
      {CIS_ODD:8, NAZEV:'PROVOZ POCITACE', SEF:51},
      {CIS_ODD:10, NAZEV:'REDITELSTVI', SEF:77},
    ]
  },
  ZAM: {
    columns: ['OS_CIS','JMENO','FCE','PLAT','TITUL','CIS_ODD','NADR'],
    pk: 'OS_CIS',
    rows: [
      {OS_CIS:1, JMENO:'KONADRA', FCE:'POSLICEK', PLAT:5400, TITUL:null, CIS_ODD:1, NADR:6},
      {OS_CIS:2, JMENO:'SYKORA', FCE:'BESTBOY', PLAT:6000, TITUL:null, CIS_ODD:1, NADR:6},
      {OS_CIS:3, JMENO:'STRNAD', FCE:'SVACINAR', PLAT:7500, TITUL:null, CIS_ODD:1, NADR:6},
      {OS_CIS:4, JMENO:'KOS', FCE:'PROJEKTANT', PLAT:10500, TITUL:'ING', CIS_ODD:1, NADR:6},
      {OS_CIS:5, JMENO:'KOS', FCE:'PROJEKTANT', PLAT:10800, TITUL:'ING', CIS_ODD:1, NADR:6},
      {OS_CIS:6, JMENO:'VOREL', FCE:'BOSS', PLAT:12000, TITUL:'ING', CIS_ODD:1, NADR:7},
      {OS_CIS:7, JMENO:'DATEL', FCE:'BOSS', PLAT:12600, TITUL:'RNDR', CIS_ODD:1, NADR:77},
      {OS_CIS:8, JMENO:'MALY', FCE:'POSLICEK', PLAT:6000, TITUL:null, CIS_ODD:2, NADR:11},
      {OS_CIS:9, JMENO:'DLOUHY', FCE:'KNIHOVNIK', PLAT:9000, TITUL:null, CIS_ODD:2, NADR:11},
      {OS_CIS:10, JMENO:'VYSOKY', FCE:'KNIHOVNIK', PLAT:10500, TITUL:null, CIS_ODD:2, NADR:11},
      {OS_CIS:11, JMENO:'TLUSTY', FCE:'KNIHOVNIK', PLAT:11100, TITUL:'ING', CIS_ODD:2, NADR:13},
      {OS_CIS:12, JMENO:'TLUSTY', FCE:'SVACINAR', PLAT:6000, TITUL:null, CIS_ODD:2, NADR:13},
      {OS_CIS:13, JMENO:'OTYLY', FCE:'BOSS', PLAT:12000, TITUL:'ING', CIS_ODD:2, NADR:14},
      {OS_CIS:14, JMENO:'OBROVSKY', FCE:'BOSS', PLAT:13500, TITUL:'RNDR', CIS_ODD:2, NADR:77},
      {OS_CIS:15, JMENO:'CERNY', FCE:'PROGRAMATOR', PLAT:7500, TITUL:null, CIS_ODD:3, NADR:21},
      {OS_CIS:16, JMENO:'CERVENY', FCE:'PROGRAMATOR', PLAT:9000, TITUL:null, CIS_ODD:3, NADR:21},
      {OS_CIS:17, JMENO:'ZELENY', FCE:'PROGRAMATOR', PLAT:10500, TITUL:'ING', CIS_ODD:3, NADR:21},
      {OS_CIS:18, JMENO:'ZELENY', FCE:'PROGRAMATOR', PLAT:10500, TITUL:'ING', CIS_ODD:3, NADR:21},
      {OS_CIS:19, JMENO:'FIALKA', FCE:'PROGRAMATOR', PLAT:10500, TITUL:'ING', CIS_ODD:3, NADR:21},
      {OS_CIS:20, JMENO:'FIALOVA', FCE:'PROGRAMATOR', PLAT:10200, TITUL:'RNDR', CIS_ODD:3, NADR:21},
      {OS_CIS:21, JMENO:'ZLATUSKA', FCE:'BOSS', PLAT:13500, TITUL:'RNDR', CIS_ODD:3, NADR:77},
      {OS_CIS:31, JMENO:'SEBESTOVA', FCE:'BOSS', PLAT:8400, TITUL:null, CIS_ODD:4, NADR:77},
      {OS_CIS:32, JMENO:'MACHOVA', FCE:'BUFETACKA', PLAT:7500, TITUL:null, CIS_ODD:4, NADR:31},
      {OS_CIS:33, JMENO:'HORACKOVA', FCE:'UKLIZECKA', PLAT:7500, TITUL:null, CIS_ODD:4, NADR:31},
      {OS_CIS:34, JMENO:'HORACKOVA', FCE:'BUFETACKA', PLAT:7800, TITUL:null, CIS_ODD:4, NADR:31},
      {OS_CIS:35, JMENO:'PAZOUTOVA', FCE:'MYCKA NADOBI', PLAT:6600, TITUL:null, CIS_ODD:4, NADR:31},
      {OS_CIS:36, JMENO:'KADRNOZKOVA', FCE:'MYCKA NADOBI', PLAT:6600, TITUL:null, CIS_ODD:4, NADR:31},
      {OS_CIS:37, JMENO:'JONATANOVA', FCE:'UKLIZECKA', PLAT:6600, TITUL:null, CIS_ODD:4, NADR:31},
      {OS_CIS:41, JMENO:'CECH', FCE:'BOSS', PLAT:9000, TITUL:'ING', CIS_ODD:6, NADR:77},
      {OS_CIS:42, JMENO:'SLOVAK', FCE:'SKLADNIK', PLAT:6600, TITUL:null, CIS_ODD:6, NADR:41},
      {OS_CIS:43, JMENO:'NEMEC', FCE:'SKLADNIK', PLAT:7200, TITUL:null, CIS_ODD:6, NADR:41},
      {OS_CIS:44, JMENO:'CECH', FCE:'SKLADNIK', PLAT:7500, TITUL:null, CIS_ODD:6, NADR:41},
      {OS_CIS:51, JMENO:'KOCOUR', FCE:'BOSS', PLAT:12900, TITUL:'DOC', CIS_ODD:8, NADR:77},
      {OS_CIS:52, JMENO:'KOCOUR', FCE:'SEF TECHNIK', PLAT:11400, TITUL:'ING', CIS_ODD:8, NADR:51},
      {OS_CIS:53, JMENO:'KOBYLKA', FCE:'TECHNIK', PLAT:10500, TITUL:'ING', CIS_ODD:8, NADR:52},
      {OS_CIS:54, JMENO:'KOCICKA', FCE:'TECHNIK', PLAT:10200, TITUL:null, CIS_ODD:8, NADR:52},
      {OS_CIS:55, JMENO:'PAPOUSEK', FCE:'TECHNIK', PLAT:10200, TITUL:null, CIS_ODD:8, NADR:52},
      {OS_CIS:77, JMENO:'SEFICEK', FCE:'REDITEL', PLAT:15000, TITUL:'DOC', CIS_ODD:10, NADR:null},
    ]
  },
  UKOLY: {
    columns: ['CIS_UK','POPIS','OS_CIS','DATUM'],
    pk: 'CIS_UK',
    rows: [
      {CIS_UK:101, POPIS:'PRINEST POSTU', OS_CIS:1, DATUM:'10/02/15'},
      {CIS_UK:102, POPIS:'ZAPLATIT SLOZENKY', OS_CIS:1, DATUM:'02/10/15'},
      {CIS_UK:105, POPIS:'POSTAVIT PODRIZENE DO LATE', OS_CIS:21, DATUM:'10/02/15'},
      {CIS_UK:106, POPIS:'ROZDELIT PRACI NA PROJEKTU FIS', OS_CIS:21, DATUM:'02/10/15'},
      {CIS_UK:107, POPIS:'ROZDELIT PRACI NA PROJEKTU KIS', OS_CIS:7, DATUM:'02/09/15'},
      {CIS_UK:108, POPIS:'DOJIT PRO SALAM A PIVKO', OS_CIS:3, DATUM:'02/11/15'},
      {CIS_UK:109, POPIS:'SEHNAT NECO NA ZUB', OS_CIS:12, DATUM:'15/10/15'},
      {CIS_UK:110, POPIS:'ZARADIT NOVE TITULY', OS_CIS:10, DATUM:'22/12/15'},
      {CIS_UK:111, POPIS:'DOKONCIT PROGRAM X57', OS_CIS:19, DATUM:'02/01/15'},
      {CIS_UK:112, POPIS:'ODLADIT ROZDELANE PROGRAMY', OS_CIS:20, DATUM:'02/12/15'},
      {CIS_UK:113, POPIS:'ZDOKUMENTOVAT PROGRAMY', OS_CIS:19, DATUM:'02/12/15'},
      {CIS_UK:114, POPIS:'PROVEST INVENTURU SKLADU C.13', OS_CIS:42, DATUM:'02/06/15'},
      {CIS_UK:115, POPIS:'KONECNE UKLIDIT', OS_CIS:37, DATUM:'10/07/15'},
      {CIS_UK:120, POPIS:'SEHNAT NOVE LIDI DO TYMU', OS_CIS:7, DATUM:'30/10/15'},
    ]
  },
  DUAL: {
    columns: ['DUMMY'],
    pk: null,
    rows: [{DUMMY: 'X'}]
  }
};

// ============================================================
// SQL TOKENIZER
// ============================================================
const TOKEN_PATTERNS = [
  { type: 'comment_line', regex: /--[^\n]*/ },
  { type: 'comment_block', regex: /\/\*[\s\S]*?\*\// },
  { type: 'string', regex: /'(?:[^']|'')*'/ },
  { type: 'dqstring', regex: /"(?:[^"]|"")*"/ },
  { type: 'number', regex: /\b\d+(?:\.\d+)?\b/ },
  { type: 'concat', regex: /\|\|/ },
  { type: 'op', regex: /[<>!=]=?|[+\-\/]/ },
  { type: 'paren_open', regex: /\(/ },
  { type: 'paren_close', regex: /\)/ },
  { type: 'comma', regex: /,/ },
  { type: 'dot', regex: /\./ },
  { type: 'star', regex: /\*/ },
  { type: 'word', regex: /[A-Za-z_ƒå≈†≈Ω√Å√â√ç√ì√ö≈Æ√ù≈ò≈§ƒé≈áƒç≈°≈æ√°√©√≠√≥√∫≈Ø√Ω≈ô≈•ƒè≈à][A-Za-z0-9_ƒå≈†≈Ω√Å√â√ç√ì√ö≈Æ√ù≈ò≈§ƒé≈áƒç≈°≈æ√°√©√≠√≥√∫≈Ø√Ω≈ô≈•ƒè≈à]*/ },
  { type: 'ws', regex: /\s+/ },
];

function tokenize(sql) {
  const tokens = [];
  let pos = 0;
  while (pos < sql.length) {
    let matched = false;
    for (const pat of TOKEN_PATTERNS) {
      const m = sql.slice(pos).match(new RegExp('^(' + pat.regex.source + ')'));
      if (m) { tokens.push({ type: pat.type, value: m[1], pos }); pos += m[1].length; matched = true; break; }
    }
    if (!matched) { tokens.push({ type: 'unknown', value: sql[pos], pos }); pos++; }
  }
  return tokens;
}

// ============================================================
// SYNTAX HIGHLIGHTER
// ============================================================
const SELECT_KW = new Set(['SELECT','DISTINCT']);
const FROM_KW = new Set(['FROM']);
const WHERE_KW = new Set(['WHERE','AND','OR','NOT','IN','BETWEEN','LIKE','IS','NULL','EXISTS']);
const JOIN_KW = new Set(['JOIN','INNER','LEFT','RIGHT','FULL','OUTER','CROSS','ON','USING','NATURAL']);
const AGG_FN = new Set(['COUNT','SUM','AVG','MAX','MIN']);
const SCALAR_FN = new Set(['ROUND','UPPER','LOWER','LENGTH','SUBSTR','TRIM','ABS','NVL','NVL2','NULLIF','COALESCE','MOD','CEIL','FLOOR','TRUNC','REPLACE','LPAD','RPAD','INSTR','INITCAP','TO_CHAR','TO_NUMBER','DECODE','GREATEST','LEAST','SIGN','POWER','SQRT']);

function highlightSQL(sql) {
  const tokens = tokenize(sql);
  let html = '', clause = '', parenDepth = 0, subqueryStack = [];
  for (let i = 0; i < tokens.length; i++) {
    const t = tokens[i], esc = escapeHTML(t.value);
    if (t.type === 'comment_line' || t.type === 'comment_block') { html += `<span class="syn-comment">${esc}</span>`; continue; }
    if (t.type === 'string' || t.type === 'dqstring') { html += `<span class="syn-string">${esc}</span>`; continue; }
    if (t.type === 'number') { html += `<span class="syn-number">${esc}</span>`; continue; }
    if (t.type === 'ws') { html += esc; continue; }
    if (t.type === 'comma') { html += `<span class="syn-comma">${esc}</span>`; continue; }
    if (t.type === 'dot') { html += `<span class="syn-dot">${esc}</span>`; continue; }
    if (t.type === 'paren_open') {
      parenDepth++;
      let j = i + 1; while (j < tokens.length && tokens[j].type === 'ws') j++;
      if (j < tokens.length && tokens[j].type === 'word' && tokens[j].value.toUpperCase() === 'SELECT') subqueryStack.push(clause);
      html += `<span class="syn-paren">${esc}</span>`; continue;
    }
    if (t.type === 'paren_close') {
      parenDepth--;
      if (subqueryStack.length > 0 && parenDepth < subqueryStack.length) clause = subqueryStack.pop() || '';
      html += `<span class="syn-paren">${esc}</span>`; continue;
    }
    if (t.type === 'concat' || t.type === 'op') { html += `<span class="syn-operator">${esc}</span>`; continue; }
    if (t.type === 'star') { html += `<span class="syn-star">${esc}</span>`; continue; }
    if (t.type === 'word') {
      const w = t.value.toUpperCase();
      if (w === 'SELECT' || w === 'DISTINCT') { clause = 'select'; html += `<span class="syn-select">${esc}</span>`; continue; }
      if (w === 'FROM') { clause = 'from'; html += `<span class="syn-from">${esc}</span>`; continue; }
      if (w === 'WHERE') { clause = 'where'; html += `<span class="syn-where">${esc}</span>`; continue; }
      if ((w === 'JOIN' || w === 'INNER' || w === 'LEFT' || w === 'RIGHT' || w === 'FULL' || w === 'CROSS' || w === 'NATURAL') && isJoinCtx(tokens, i)) { clause = 'join'; html += `<span class="syn-join">${esc}</span>`; continue; }
      if (w === 'ON' || w === 'USING') { clause = 'join'; html += `<span class="syn-join">${esc}</span>`; continue; }
      if (w === 'GROUP') { clause = 'group'; html += `<span class="syn-group">${esc}</span>`; continue; }
      if (w === 'HAVING') { clause = 'having'; html += `<span class="syn-having">${esc}</span>`; continue; }
      if (w === 'ORDER') { clause = 'order'; html += `<span class="syn-order">${esc}</span>`; continue; }
      if (w === 'BY' && (clause === 'group' || clause === 'order')) { html += `<span class="${clause === 'group' ? 'syn-group' : 'syn-order'}">${esc}</span>`; continue; }
      if (AGG_FN.has(w)) { html += `<span class="syn-agg">${esc}</span>`; continue; }
      if (SCALAR_FN.has(w)) { html += `<span class="syn-agg">${esc}</span>`; continue; }
      if (WHERE_KW.has(w) && (clause === 'where' || clause === 'having')) { html += `<span class="${clause === 'having' ? 'syn-having' : 'syn-where'}">${esc}</span>`; continue; }
      if (w === 'ASC' || w === 'DESC') { html += `<span class="syn-order">${esc}</span>`; continue; }
      if (w === 'AS') { html += `<span class="syn-alias">${esc}</span>`; continue; }
      if (w === 'CASE' || w === 'WHEN' || w === 'THEN' || w === 'ELSE' || w === 'END') { html += `<span class="syn-agg">${esc}</span>`; continue; }
      if (w === 'UNION' || w === 'INTERSECT' || w === 'MINUS') { html += `<span class="syn-select">${esc}</span>`; continue; }
      if (w === 'ALL' && i > 0 && tokens[i-1].type === 'word' && tokens[i-1].value.toUpperCase() === 'UNION') { html += `<span class="syn-select">${esc}</span>`; continue; }
      if (w === 'ROWNUM') { html += `<span class="syn-agg">${esc}</span>`; continue; }
      html += esc; continue;
    }
    html += esc;
  }
  return html;
}

function isJoinCtx(tokens, idx) {
  const w = tokens[idx].value.toUpperCase();
  if (w === 'JOIN') return true;
  for (let i = idx + 1; i < tokens.length && i < idx + 4; i++) {
    if (tokens[i].type === 'ws') continue;
    if (tokens[i].type === 'word' && tokens[i].value.toUpperCase() === 'JOIN') return true;
    break;
  }
  return false;
}

function escapeHTML(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

// ============================================================
// SQL PARSER
// ============================================================
function parseSQL(sql) {
  sql = sql.replace(/--[^\n]*/g, '').replace(/\/\*[\s\S]*?\*\//g, '');
  const trimmed = sql.trim().replace(/;+\s*$/, '');
  if (!trimmed) throw new Error('Pr√°zdn√Ω dotaz');
  const tokens = tokenize(trimmed).filter(t => t.type !== 'ws');
  if (tokens.length === 0) throw new Error('Pr√°zdn√Ω dotaz');
  if (tokens[0].type !== 'word' || tokens[0].value.toUpperCase() !== 'SELECT') throw new Error('Dotaz mus√≠ zaƒç√≠nat slovem SELECT');
  let q = parseSelect(tokens, 0);
  let pos = q.__endPos || tokens.length;
  while (pos < tokens.length && tokens[pos].type === 'word') {
    const kw = tokens[pos].value.toUpperCase();
    let op = null;
    if (kw === 'UNION') { pos++; if (pos < tokens.length && tokens[pos].type === 'word' && tokens[pos].value.toUpperCase() === 'ALL') { op = 'UNION ALL'; pos++; } else op = 'UNION'; }
    else if (kw === 'INTERSECT') { op = 'INTERSECT'; pos++; }
    else if (kw === 'MINUS') { op = 'MINUS'; pos++; }
    else break;
    if (pos < tokens.length && tokens[pos].type === 'word' && tokens[pos].value.toUpperCase() === 'SELECT') {
      const right = parseSelect(tokens, pos);
      q = { type: 'set_op', op, left: q, right };
      pos = right.__endPos || tokens.length;
    } else break;
  }
  return q;
}

function parseSelect(tokens, start) {
  let pos = start;
  const q = { type:'select', distinct:false, columns:[], from:[], joins:[], where:null, groupBy:[], having:null, orderBy:[] };
  pos++;
  if (pos < tokens.length && tokens[pos].type === 'word' && tokens[pos].value.toUpperCase() === 'DISTINCT') { q.distinct = true; pos++; }
  const cr = parseColumnList(tokens, pos); q.columns = cr.columns; pos = cr.pos;
  if (pos < tokens.length && tokens[pos].type === 'word' && tokens[pos].value.toUpperCase() === 'FROM') { pos++; const fr = parseFromClause(tokens, pos); q.from = fr.tables; pos = fr.pos; }
  while (pos < tokens.length) { const w = tokens[pos].type === 'word' ? tokens[pos].value.toUpperCase() : ''; if (['JOIN','INNER','LEFT','RIGHT','FULL','CROSS','NATURAL'].includes(w)) { const jr = parseJoin(tokens, pos); q.joins.push(jr.join); pos = jr.pos; } else break; }
  if (pos < tokens.length && tokens[pos].type === 'word' && tokens[pos].value.toUpperCase() === 'WHERE') { pos++; const wr = parseExpression(tokens, pos, ['GROUP','HAVING','ORDER','UNION','INTERSECT','MINUS']); q.where = wr.expr; pos = wr.pos; }
  if (pos < tokens.length && tokens[pos].type === 'word' && tokens[pos].value.toUpperCase() === 'GROUP') { pos++; if (pos < tokens.length && tokens[pos].type === 'word' && tokens[pos].value.toUpperCase() === 'BY') pos++; const gr = parseExpressionList(tokens, pos, ['HAVING','ORDER','UNION','INTERSECT','MINUS']); q.groupBy = gr.exprs; pos = gr.pos; }
  if (pos < tokens.length && tokens[pos].type === 'word' && tokens[pos].value.toUpperCase() === 'HAVING') { pos++; const hr = parseExpression(tokens, pos, ['ORDER','UNION','INTERSECT','MINUS']); q.having = hr.expr; pos = hr.pos; }
  if (pos < tokens.length && tokens[pos].type === 'word' && tokens[pos].value.toUpperCase() === 'ORDER') { pos++; if (pos < tokens.length && tokens[pos].type === 'word' && tokens[pos].value.toUpperCase() === 'BY') pos++; const or = parseOrderByList(tokens, pos); q.orderBy = or.items; pos = or.pos; }
  q.__endPos = pos;
  return q;
}
function parseColumnList(tokens, pos) { const cols=[]; while(pos<tokens.length){const w=tokens[pos].type==='word'?tokens[pos].value.toUpperCase():'';if(['FROM','WHERE','GROUP','HAVING','ORDER'].includes(w))break;if(tokens[pos].type==='star'){cols.push({type:'star'});pos++;}else{const er=parseExpr(tokens,pos);const col={type:'expr',expr:er.expr,alias:null};pos=er.pos;if(pos<tokens.length&&tokens[pos].type==='word'&&tokens[pos].value.toUpperCase()==='AS'){pos++;if(pos<tokens.length){col.alias=tokens[pos].type==='dqstring'?tokens[pos].value.slice(1,-1):tokens[pos].value;pos++;}}else if(pos<tokens.length&&tokens[pos].type==='word'){const nw=tokens[pos].value.toUpperCase();if(!['FROM','WHERE','GROUP','HAVING','ORDER','JOIN','INNER','LEFT','RIGHT','FULL','CROSS','NATURAL','ON','USING'].includes(nw)){col.alias=tokens[pos].value;pos++;}}cols.push(col);}if(pos<tokens.length&&tokens[pos].type==='comma'){pos++;continue;}break;}return{columns:cols,pos};}
function parseFromClause(tokens, pos) { const tables=[]; while(pos<tokens.length){const w=tokens[pos].type==='word'?tokens[pos].value.toUpperCase():'';if(['WHERE','GROUP','HAVING','ORDER','JOIN','INNER','LEFT','RIGHT','FULL','CROSS','NATURAL'].includes(w))break;if(tokens[pos].type==='paren_open'){pos++;const sq=parseSelect(tokens,pos);let d=1;while(pos<tokens.length&&d>0){if(tokens[pos].type==='paren_open')d++;else if(tokens[pos].type==='paren_close'){d--;if(d===0){pos++;break;}}pos++;}let al=null;if(pos<tokens.length&&tokens[pos].type==='word'&&tokens[pos].value.toUpperCase()==='AS')pos++;if(pos<tokens.length&&tokens[pos].type==='word'){const nw=tokens[pos].value.toUpperCase();if(!['WHERE','GROUP','HAVING','ORDER','JOIN','INNER','LEFT','RIGHT','FULL','CROSS','NATURAL'].includes(nw)){al=tokens[pos].value;pos++;}}tables.push({type:'subquery',query:sq,alias:al});}else if(tokens[pos].type==='word'){const t={type:'table',name:tokens[pos].value.toUpperCase(),alias:null};pos++;if(pos<tokens.length&&tokens[pos].type==='word'){const nw=tokens[pos].value.toUpperCase();if(nw==='AS'){pos++;if(pos<tokens.length&&tokens[pos].type==='word'){t.alias=tokens[pos].value.toUpperCase();pos++;}}else if(!['WHERE','GROUP','HAVING','ORDER','JOIN','INNER','LEFT','RIGHT','FULL','CROSS','NATURAL','ON','USING'].includes(nw)){t.alias=tokens[pos].value.toUpperCase();pos++;}}tables.push(t);}else break;if(pos<tokens.length&&tokens[pos].type==='comma'){pos++;continue;}break;}return{tables,pos};}
function parseJoin(tokens, pos) { let jt='INNER';const w=tokens[pos].value.toUpperCase();if(w==='LEFT'){jt='LEFT';pos++;if(pos<tokens.length&&tokens[pos].type==='word'&&tokens[pos].value.toUpperCase()==='OUTER')pos++;}else if(w==='RIGHT'){jt='RIGHT';pos++;if(pos<tokens.length&&tokens[pos].type==='word'&&tokens[pos].value.toUpperCase()==='OUTER')pos++;}else if(w==='FULL'){jt='FULL';pos++;if(pos<tokens.length&&tokens[pos].type==='word'&&tokens[pos].value.toUpperCase()==='OUTER')pos++;}else if(w==='CROSS'){jt='CROSS';pos++;}else if(w==='INNER')pos++;else if(w==='NATURAL'){jt='NATURAL';pos++;}if(pos<tokens.length&&tokens[pos].type==='word'&&tokens[pos].value.toUpperCase()==='JOIN')pos++;const tn=tokens[pos].value.toUpperCase();pos++;let al=null;if(pos<tokens.length&&tokens[pos].type==='word'){const nw=tokens[pos].value.toUpperCase();if(nw==='AS'){pos++;if(pos<tokens.length){al=tokens[pos].value.toUpperCase();pos++;}}else if(!['ON','USING','WHERE','GROUP','HAVING','ORDER','JOIN','INNER','LEFT','RIGHT','FULL','CROSS','NATURAL'].includes(nw)){al=tokens[pos].value.toUpperCase();pos++;}}const j={type:jt,table:tn,alias:al,on:null,using:null};if(pos<tokens.length&&tokens[pos].type==='word'&&tokens[pos].value.toUpperCase()==='ON'){pos++;const r=parseExpression(tokens,pos,['WHERE','GROUP','HAVING','ORDER','JOIN','INNER','LEFT','RIGHT','FULL','CROSS','NATURAL']);j.on=r.expr;pos=r.pos;}else if(pos<tokens.length&&tokens[pos].type==='word'&&tokens[pos].value.toUpperCase()==='USING'){pos++;if(pos<tokens.length&&tokens[pos].type==='paren_open'){pos++;j.using=[];while(pos<tokens.length&&tokens[pos].type!=='paren_close'){if(tokens[pos].type==='word')j.using.push(tokens[pos].value.toUpperCase());pos++;}if(pos<tokens.length)pos++;}}return{join:j,pos};}
function parseExpression(tokens, pos, sw) { const r=parseExpr(tokens,pos,sw); return{expr:r.expr,pos:r.pos}; }
function parseExpr(tokens, pos, sw) { return parseOr(tokens,pos,sw); }
function parseOr(t,p,s){let l=parseAnd(t,p,s);p=l.pos;while(p<t.length&&t[p].type==='word'&&t[p].value.toUpperCase()==='OR'){p++;const r=parseAnd(t,p,s);l={expr:{type:'binary',op:'OR',left:l.expr,right:r.expr},pos:r.pos};p=r.pos;}return l;}
function parseAnd(t,p,s){let l=parseNot(t,p,s);p=l.pos;while(p<t.length&&t[p].type==='word'&&t[p].value.toUpperCase()==='AND'){p++;const r=parseNot(t,p,s);l={expr:{type:'binary',op:'AND',left:l.expr,right:r.expr},pos:r.pos};p=r.pos;}return l;}
function parseNot(t,p,s){if(p<t.length&&t[p].type==='word'&&t[p].value.toUpperCase()==='NOT'){p++;const i=parseNot(t,p,s);return{expr:{type:'unary',op:'NOT',operand:i.expr},pos:i.pos};}return parseComparison(t,p,s);}
function parseComparison(t,p,s){let l=parseConcat(t,p,s);p=l.pos;if(p>=t.length)return l;if(t[p].type==='word'&&t[p].value.toUpperCase()==='IS'){p++;let n=false;if(p<t.length&&t[p].type==='word'&&t[p].value.toUpperCase()==='NOT'){n=true;p++;}if(p<t.length&&t[p].type==='word'&&t[p].value.toUpperCase()==='NULL'){p++;return{expr:{type:'is_null',expr:l.expr,not:n},pos:p};}}if(t[p].type==='word'&&t[p].value.toUpperCase()==='IN'){p++;if(p<t.length&&t[p].type==='paren_open'){const p2=p+1+(t[p+1]&&t[p+1].type==='ws'?1:0);const isSubq=p+1<t.length&&t[p+1].type==='word'&&t[p+1].value.toUpperCase()==='SELECT';if(isSubq){p++;const sq=parseSelect(t,p);let d=1;while(p<t.length&&d>0){if(t[p].type==='paren_open')d++;else if(t[p].type==='paren_close'){d--;if(d===0){p++;break;}}p++;}return{expr:{type:'in',expr:l.expr,values:[{type:'subquery',query:sq}]},pos:p};}else{p++;const v=[];while(p<t.length&&t[p].type!=='paren_close'){if(t[p].type==='comma'){p++;continue;}const x=parseExpr(t,p,s);v.push(x.expr);p=x.pos;}if(p<t.length)p++;return{expr:{type:'in',expr:l.expr,values:v},pos:p};}}}if(t[p].type==='word'&&t[p].value.toUpperCase()==='NOT'&&p+1<t.length&&t[p+1].type==='word'&&t[p+1].value.toUpperCase()==='IN'){p+=2;if(p<t.length&&t[p].type==='paren_open'){const isSubq=p+1<t.length&&t[p+1].type==='word'&&t[p+1].value.toUpperCase()==='SELECT';if(isSubq){p++;const sq=parseSelect(t,p);let d=1;while(p<t.length&&d>0){if(t[p].type==='paren_open')d++;else if(t[p].type==='paren_close'){d--;if(d===0){p++;break;}}p++;}return{expr:{type:'unary',op:'NOT',operand:{type:'in',expr:l.expr,values:[{type:'subquery',query:sq}]}},pos:p};}else{p++;const v=[];while(p<t.length&&t[p].type!=='paren_close'){if(t[p].type==='comma'){p++;continue;}const x=parseExpr(t,p,s);v.push(x.expr);p=x.pos;}if(p<t.length)p++;return{expr:{type:'unary',op:'NOT',operand:{type:'in',expr:l.expr,values:v}},pos:p};}}}if(t[p].type==='word'&&t[p].value.toUpperCase()==='BETWEEN'){p++;const lo=parseConcat(t,p,s);p=lo.pos;if(p<t.length&&t[p].type==='word'&&t[p].value.toUpperCase()==='AND')p++;const hi=parseConcat(t,p,s);p=hi.pos;return{expr:{type:'between',expr:l.expr,low:lo.expr,high:hi.expr},pos:p};}if(t[p].type==='word'&&t[p].value.toUpperCase()==='LIKE'){p++;const pa=parseConcat(t,p,s);return{expr:{type:'like',expr:l.expr,pattern:pa.expr},pos:pa.pos};}if(t[p].type==='word'&&t[p].value.toUpperCase()==='NOT'&&p+1<t.length&&t[p+1].type==='word'&&t[p+1].value.toUpperCase()==='LIKE'){p+=2;const pa=parseConcat(t,p,s);return{expr:{type:'unary',op:'NOT',operand:{type:'like',expr:l.expr,pattern:pa.expr}},pos:pa.pos};}if(t[p].type==='op'){const op=t[p].value;if(['=','!=','<>','<','>','<=','>='].includes(op)){p++;const r=parseConcat(t,p,s);return{expr:{type:'binary',op:op==='<>'?'!=':op,left:l.expr,right:r.expr},pos:r.pos};}}return l;}
function parseConcat(t,p,s){let l=parseAddSub(t,p,s);p=l.pos;while(p<t.length&&t[p].type==='concat'){p++;const r=parseAddSub(t,p,s);l={expr:{type:'binary',op:'||',left:l.expr,right:r.expr},pos:r.pos};p=r.pos;}return l;}
function parseAddSub(t,p,s){let l=parseMulDiv(t,p,s);p=l.pos;while(p<t.length&&t[p].type==='op'&&(t[p].value==='+'||t[p].value==='-')){const op=t[p].value;p++;const r=parseMulDiv(t,p,s);l={expr:{type:'binary',op,left:l.expr,right:r.expr},pos:r.pos};p=r.pos;}return l;}
function parseMulDiv(t,p,s){let l=parseAtom(t,p,s);p=l.pos;while(p<t.length&&((t[p].type==='op'&&t[p].value==='/')||t[p].type==='star')){const op=t[p].type==='star'?'*':t[p].value;p++;const r=parseAtom(t,p,s);l={expr:{type:'binary',op,left:l.expr,right:r.expr},pos:r.pos};p=r.pos;}return l;}
function parseAtom(t,p,s){if(p>=t.length)return{expr:{type:'literal',value:null},pos:p};const tk=t[p];if(s&&tk.type==='word'&&s.includes(tk.value.toUpperCase()))return{expr:{type:'literal',value:null},pos:p};if(tk.type==='word'&&tk.value.toUpperCase()==='NULL')return{expr:{type:'literal',value:null},pos:p+1};if(tk.type==='number'){const n=tk.value.includes('.')?parseFloat(tk.value):parseInt(tk.value,10);return{expr:{type:'literal',value:n},pos:p+1};}if(tk.type==='string'){const v=tk.value.slice(1,-1).replace(/''/g,"'");return{expr:{type:'literal',value:v},pos:p+1};}if(tk.type==='star')return{expr:{type:'star'},pos:p+1};if(tk.type==='paren_open'){p++;if(p<t.length&&t[p].type==='word'&&t[p].value.toUpperCase()==='SELECT'){const sq=parseSelect(t,p);let d=1;while(p<t.length&&d>0){if(t[p].type==='paren_open')d++;else if(t[p].type==='paren_close'){d--;if(d===0){p++;break;}}p++;}return{expr:{type:'subquery',query:sq},pos:p};}const inner=parseExpr(t,p,s);p=inner.pos;if(p<t.length&&t[p].type==='paren_close')p++;return{expr:inner.expr,pos:p};}if(tk.type==='word'&&AGG_FN.has(tk.value.toUpperCase())){const fn=tk.value.toUpperCase();p++;if(p<t.length&&t[p].type==='paren_open'){p++;let dist=false;if(p<t.length&&t[p].type==='word'&&t[p].value.toUpperCase()==='DISTINCT'){dist=true;p++;}if(p<t.length&&t[p].type==='star'){p++;if(p<t.length&&t[p].type==='paren_close')p++;return{expr:{type:'agg',fn,arg:{type:'star'},distinct:dist},pos:p};}const a=parseExpr(t,p,s);p=a.pos;if(p<t.length&&t[p].type==='paren_close')p++;return{expr:{type:'agg',fn,arg:a.expr,distinct:dist},pos:p};}}if(tk.type==='word'&&tk.value.toUpperCase()==='CASE'){p++;const whens=[];let elseExpr=null;let simple=null;if(p<t.length&&t[p].type==='word'&&t[p].value.toUpperCase()!=='WHEN'){const sr=parseExpr(t,p,s);simple=sr.expr;p=sr.pos;}while(p<t.length&&t[p].type==='word'&&t[p].value.toUpperCase()==='WHEN'){p++;const wr=parseExpr(t,p,s);p=wr.pos;if(p<t.length&&t[p].type==='word'&&t[p].value.toUpperCase()==='THEN')p++;const tr=parseExpr(t,p,s);p=tr.pos;whens.push({when:wr.expr,then:tr.expr});}if(p<t.length&&t[p].type==='word'&&t[p].value.toUpperCase()==='ELSE'){p++;const er=parseExpr(t,p,s);elseExpr=er.expr;p=er.pos;}if(p<t.length&&t[p].type==='word'&&t[p].value.toUpperCase()==='END')p++;return{expr:{type:'case',simple,whens,else:elseExpr},pos:p};}if(tk.type==='word'&&tk.value.toUpperCase()==='EXISTS'&&p+1<t.length&&t[p+1].type==='paren_open'){p+=2;const sq=parseSelect(t,p);let d=1;while(p<t.length&&d>0){if(t[p].type==='paren_open')d++;else if(t[p].type==='paren_close'){d--;if(d===0){p++;break;}}p++;}return{expr:{type:'exists',query:sq,not:false},pos:p};}if(tk.type==='word'&&SCALAR_FN.has(tk.value.toUpperCase())&&p+1<t.length&&t[p+1].type==='paren_open'){const fn=tk.value.toUpperCase();p+=2;const args=[];while(p<t.length&&t[p].type!=='paren_close'){if(t[p].type==='comma'){p++;continue;}const a=parseExpr(t,p,s);args.push(a.expr);p=a.pos;}if(p<t.length)p++;return{expr:{type:'func',fn,args},pos:p};}if(tk.type==='word'){p++;if(p<t.length&&t[p].type==='dot'){p++;if(p<t.length&&(t[p].type==='word'||t[p].type==='star')){const c=t[p].type==='star'?'*':t[p].value.toUpperCase();p++;return{expr:{type:'column',table:tk.value.toUpperCase(),name:c},pos:p};}}return{expr:{type:'column',table:null,name:tk.value.toUpperCase()},pos:p};}if(tk.type==='op'&&tk.value==='-'){p++;const inner=parseAtom(t,p,s);return{expr:{type:'unary',op:'-',operand:inner.expr},pos:inner.pos};}p++;return{expr:{type:'literal',value:null},pos:p};}
function parseExpressionList(t,p,s){const e=[];while(p<t.length){if(t[p].type==='word'&&s&&s.includes(t[p].value.toUpperCase()))break;const r=parseExpr(t,p,s);e.push(r.expr);p=r.pos;if(p<t.length&&t[p].type==='comma'){p++;continue;}break;}return{exprs:e,pos:p};}
function parseOrderByList(t,p){const items=[];while(p<t.length){const r=parseExpr(t,p,[]);let d='ASC';p=r.pos;if(p<t.length&&t[p].type==='word'){const v=t[p].value.toUpperCase();if(v==='ASC'||v==='DESC'){d=v;p++;}}items.push({expr:r.expr,dir:d});if(p<t.length&&t[p].type==='comma'){p++;continue;}break;}return{items,pos:p};}

// ============================================================
// SQL EXECUTOR
// ============================================================
function executeAST(query) {
  // Handle set operations (UNION, INTERSECT, MINUS)
  if (query.type === 'set_op') {
    const left = executeAST(query.left), right = executeAST(query.right);
    const cols = left.columns;
    const key = r => cols.map(c => { const v = r[c]; return v === null ? '__NULL__' : String(v); }).join('|||');
    if (query.op === 'UNION ALL') return { columns: cols, rows: [...left.rows, ...right.rows] };
    if (query.op === 'UNION') { const seen = new Set(); const res = []; for (const r of [...left.rows, ...right.rows]) { const k = key(r); if (!seen.has(k)) { seen.add(k); res.push(r); } } return { columns: cols, rows: res }; }
    if (query.op === 'INTERSECT') { const rKeys = new Set(right.rows.map(key)); const seen = new Set(); const res = []; for (const r of left.rows) { const k = key(r); if (rKeys.has(k) && !seen.has(k)) { seen.add(k); res.push(r); } } return { columns: cols, rows: res }; }
    if (query.op === 'MINUS') { const rKeys = new Set(right.rows.map(key)); const res = []; for (const r of left.rows) { if (!rKeys.has(key(r))) res.push(r); } return { columns: cols, rows: res }; }
  }
  let rows = [];
  const aliasMap = {};
  if (query.from.length === 0) { rows = [{}]; }
  else if (query.from.length === 1) {
    const src = query.from[0];
    if (src.type === 'subquery') { const sr = executeAST(src.query); rows = sr.rows.map(r => { const row = {}; for (const [k,v] of Object.entries(r)) { if (src.alias) row[src.alias.toUpperCase()+'.'+k] = v; row[k] = v; } return row; }); if (src.alias) aliasMap[src.alias.toUpperCase()] = '__subquery__'; }
    else { const tbl = getTable(src.name); rows = tbl.rows.map(r => { const row = {}; for (const col of tbl.columns) { row[col]=r[col]; row[src.name+'.'+col]=r[col]; if(src.alias) row[src.alias+'.'+col]=r[col]; } return row; }); aliasMap[src.name]=src.name; if(src.alias) aliasMap[src.alias]=src.name; }
  } else {
    rows = [{}];
    for (const src of query.from) { const tbl=getTable(src.name); const nr=[]; for(const ex of rows){for(const r of tbl.rows){const row={...ex};for(const col of tbl.columns){row[col]=r[col];row[src.name+'.'+col]=r[col];if(src.alias)row[src.alias+'.'+col]=r[col];}nr.push(row);}} rows=nr; aliasMap[src.name]=src.name; if(src.alias) aliasMap[src.alias]=src.name; }
  }
  for (const join of query.joins) {
    const tbl=getTable(join.table); const ta=join.alias||join.table; aliasMap[join.table]=join.table; if(join.alias)aliasMap[join.alias]=join.table;
    function storeJC(c,rr,v){for(const col of tbl.columns){c[ta+'.'+col]=v===null?null:rr[col];if(!join.alias)c[join.table+'.'+col]=v===null?null:rr[col];if(!(col in c))c[col]=v===null?null:rr[col];}}
    if(join.using){const nr=[];for(const lr of rows){let m=false;for(const rr of tbl.rows){let ok=true;for(const col of join.using){if(!valuesEqual(lr[col],rr[col])){ok=false;break;}}if(ok){const c={...lr};storeJC(c,rr,1);nr.push(c);m=true;}}if(!m&&(join.type==='LEFT'||join.type==='FULL')){const c={...lr};storeJC(c,{},null);nr.push(c);}}rows=nr;}
    else if(join.on){const nr=[];for(const lr of rows){let m=false;for(const rr of tbl.rows){const c={...lr};storeJC(c,rr,1);if(evalExpr(join.on,c)){nr.push(c);m=true;}}if(!m&&(join.type==='LEFT'||join.type==='FULL')){const c={...lr};storeJC(c,{},null);nr.push(c);}}rows=nr;}
    else{const nr=[];for(const lr of rows){for(const rr of tbl.rows){const c={...lr};storeJC(c,rr,1);nr.push(c);}}rows=nr;}
  }
  for(let i=0;i<rows.length;i++)rows[i].ROWNUM=i+1;
  if(query.where){rows=rows.filter(r=>evalExpr(query.where,r)===true);}
  if(query.groupBy.length>0){const g=new Map();for(const r of rows){const k=query.groupBy.map(e=>{const v=evalExpr(e,r);return v===null?'__NULL__':String(v);}).join('|||');if(!g.has(k))g.set(k,[]);g.get(k).push(r);}const gr=[];for(const[,grs]of g)gr.push({__group__:grs,...grs[0]});rows=gr;}
  else if(hasAgg(query.columns)||query.having){rows=[{__group__:rows,...(rows[0]||{})}];}
  if(query.having){rows=rows.filter(r=>evalExpr(query.having,r)===true);}
  const rc=[], rr=[];
  for(const col of query.columns){if(col.type==='star'){const ts=[...query.from,...query.joins.map(j=>({name:j.table,alias:j.alias}))];for(const t of ts){if(t.type==='subquery'){if(rows.length>0)for(const k of Object.keys(rows[0])){if(k==='__group__')continue;if(!k.includes('.'))rc.push(k);}}else{const tb=getTable(t.name);for(const c of tb.columns)rc.push(c);}}}else{let cn=(col.alias||exprName(col.expr)).toUpperCase();if(rc.includes(cn)){let s=2;while(rc.includes(cn+'_'+s))s++;cn=cn+'_'+s;}rc.push(cn);}}
  for(const row of rows){const res={};let ci=0;for(const col of query.columns){if(col.type==='star'){const ts=[...query.from,...query.joins.map(j=>({name:j.table,alias:j.alias}))];for(const t of ts){if(t.type==='subquery'){for(const k of Object.keys(row)){if(k==='__group__')continue;if(!k.includes('.')){res[k]=row[k];ci++;}}}else{const tb=getTable(t.name);for(const c of tb.columns){const al=t.alias||t.name;res[rc[ci]]=row[al+'.'+c]!==undefined?row[al+'.'+c]:row[c];ci++;}}}}else{res[rc[ci]]=evalExpr(col.expr,row);ci++;}}rr.push(res);}
  let fr=rr;if(query.distinct){const seen=new Set();fr=[];for(const r of rr){const k=rc.map(c=>r[c]===null?'__NULL__':String(r[c])).join('|||');if(!seen.has(k)){seen.add(k);fr.push(r);}}}
  if(query.orderBy.length>0){fr.sort((a,b)=>{for(const ob of query.orderBy){const va=evalExprR(ob.expr,a,rc),vb=evalExprR(ob.expr,b,rc),c=cmpVals(va,vb);if(c!==0)return ob.dir==='DESC'?-c:c;}return 0;});}
  return{columns:rc,rows:fr};
}
function getTable(n){const u=n.toUpperCase();if(DB[u])return DB[u];throw new Error(`Tabulka "${n}" neexistuje. Dostupn√©: ${Object.keys(DB).join(', ')}`);}
function valuesEqual(a,b){if(a===null||b===null)return false;return String(a).toUpperCase()===String(b).toUpperCase();}
function evalExpr(e,r){if(!e)return null;switch(e.type){case'literal':return e.value;case'star':return null;case'column':{const n=e.name;if(n==='SYSDATE'){const d=new Date();return d.getFullYear()+'-'+String(d.getMonth()+1).padStart(2,'0')+'-'+String(d.getDate()).padStart(2,'0');}if(e.table){const q=e.table+'.'+n;if(q in r)return r[q];}if(n in r)return r[n];for(const k of Object.keys(r))if(k.toUpperCase()===n||k.toUpperCase()===(e.table?e.table+'.'+n:''))return r[k];return null;}case'binary':{if(e.op==='AND')return evalExpr(e.left,r)===true&&evalExpr(e.right,r)===true;if(e.op==='OR')return evalExpr(e.left,r)===true||evalExpr(e.right,r)===true;const lv=evalExpr(e.left,r),rv=evalExpr(e.right,r);if(e.op==='||'){return (lv===null?'':String(lv))+(rv===null?'':String(rv));}if(e.op==='+'){if(lv===null||rv===null)return null;return Number(lv)+Number(rv);}if(e.op==='-'){if(lv===null||rv===null)return null;return Number(lv)-Number(rv);}if(e.op==='*'){if(lv===null||rv===null)return null;return Number(lv)*Number(rv);}if(e.op==='/'){if(lv===null||rv===null)return null;if(Number(rv)===0)throw new Error('Dƒõlen√≠ nulou');return Number(lv)/Number(rv);}if(lv===null||rv===null)return null;if(e.op==='=')return valuesEqual(lv,rv);if(e.op==='!=')return!valuesEqual(lv,rv);if(e.op==='<')return Number(lv)<Number(rv);if(e.op==='>')return Number(lv)>Number(rv);if(e.op==='<=')return Number(lv)<=Number(rv);if(e.op==='>=')return Number(lv)>=Number(rv);return null;}case'unary':{if(e.op==='NOT'){const v=evalExpr(e.operand,r);return v===null?null:!v;}if(e.op==='-'){const v=evalExpr(e.operand,r);return v===null?null:-Number(v);}return null;}case'is_null':{const v=evalExpr(e.expr,r);return e.not?v!==null:v===null;}case'like':{const v=evalExpr(e.expr,r),p=evalExpr(e.pattern,r);if(v===null||p===null)return null;const ps=String(p).toUpperCase(),vs=String(v).toUpperCase();let ri=0,pi=0;function ml(ri,pi){if(pi>=ps.length)return ri>=vs.length;if(ps[pi]==='%'){while(pi<ps.length&&ps[pi]==='%')pi++;if(pi>=ps.length)return true;for(let i=ri;i<=vs.length;i++)if(ml(i,pi))return true;return false;}if(ri>=vs.length)return false;if(ps[pi]==='_'||ps[pi]===vs[ri])return ml(ri+1,pi+1);return false;}return ml(0,0);}case'in':{const v=evalExpr(e.expr,r);if(v===null)return null;for(const val of e.values){if(val.type==='subquery'){const res=executeAST(val.query);const col=res.columns[0];for(const row of res.rows){if(valuesEqual(v,row[col]))return true;}}else{if(valuesEqual(v,evalExpr(val,r)))return true;}}return false;}case'between':{const v=evalExpr(e.expr,r),lo=evalExpr(e.low,r),hi=evalExpr(e.high,r);if(v===null||lo===null||hi===null)return null;return Number(v)>=Number(lo)&&Number(v)<=Number(hi);}case'agg':{const g=r.__group__||[r],fn=e.fn;if(fn==='COUNT'){if(e.arg.type==='star')return g.length;let c=0;const sn=e.distinct?new Set():null;for(const x of g){const v=evalExpr(e.arg,x);if(v!==null){if(sn){const sv=String(v).toUpperCase();if(!sn.has(sv)){sn.add(sv);c++;}}else c++;}}return c;}const vs=[];const sn=e.distinct?new Set():null;for(const x of g){const v=evalExpr(e.arg,x);if(v!==null){if(sn){const sv=String(v).toUpperCase();if(!sn.has(sv)){sn.add(sv);vs.push(Number(v));}}else vs.push(Number(v));}}if(vs.length===0)return null;if(fn==='SUM')return vs.reduce((a,b)=>a+b,0);if(fn==='AVG')return vs.reduce((a,b)=>a+b,0)/vs.length;if(fn==='MAX')return Math.max(...vs);if(fn==='MIN')return Math.min(...vs);return null;}case'func':{const args=e.args.map(a=>evalExpr(a,r));const fn=e.fn;if(fn==='ROUND'){const v=args[0],n=args[1]??0;if(v===null)return null;const f=Math.pow(10,Number(n));return Math.round(Number(v)*f)/f;}if(fn==='TRUNC'){const v=args[0],n=args[1]??0;if(v===null)return null;const f=Math.pow(10,Number(n));return Math.trunc(Number(v)*f)/f;}if(fn==='UPPER')return args[0]===null?null:String(args[0]).toUpperCase();if(fn==='LOWER')return args[0]===null?null:String(args[0]).toLowerCase();if(fn==='LENGTH')return args[0]===null?null:String(args[0]).length;if(fn==='SUBSTR'){if(args[0]===null)return null;const str=String(args[0]),st=Number(args[1])-1;return args[2]!=null?str.substr(st,Number(args[2])):str.substr(st);}if(fn==='TRIM')return args[0]===null?null:String(args[0]).trim();if(fn==='ABS')return args[0]===null?null:Math.abs(Number(args[0]));if(fn==='NVL')return args[0]===null?args[1]:args[0];if(fn==='COALESCE'){for(const a of args)if(a!==null)return a;return null;}if(fn==='MOD')return args[0]===null||args[1]===null?null:Number(args[0])%Number(args[1]);if(fn==='CEIL')return args[0]===null?null:Math.ceil(Number(args[0]));if(fn==='FLOOR')return args[0]===null?null:Math.floor(Number(args[0]));if(fn==='REPLACE'){if(args[0]===null)return null;return String(args[0]).split(String(args[1])).join(String(args[2]??''));}if(fn==='LPAD'){if(args[0]===null)return null;return String(args[0]).padStart(Number(args[1]),String(args[2]??' '));}if(fn==='RPAD'){if(args[0]===null)return null;return String(args[0]).padEnd(Number(args[1]),String(args[2]??' '));}if(fn==='INSTR'){if(args[0]===null||args[1]===null)return null;const i=String(args[0]).indexOf(String(args[1]));return i===-1?0:i+1;}if(fn==='INITCAP'){if(args[0]===null)return null;return String(args[0]).toLowerCase().replace(/\b\w/g,c=>c.toUpperCase());}if(fn==='TO_CHAR')return args[0]===null?null:String(args[0]);if(fn==='TO_NUMBER')return args[0]===null?null:Number(args[0]);if(fn==='GREATEST'){const vs=args.filter(a=>a!==null);return vs.length===0?null:Math.max(...vs.map(Number));}if(fn==='LEAST'){const vs=args.filter(a=>a!==null);return vs.length===0?null:Math.min(...vs.map(Number));}if(fn==='SIGN')return args[0]===null?null:Math.sign(Number(args[0]));if(fn==='POWER')return args[0]===null||args[1]===null?null:Math.pow(Number(args[0]),Number(args[1]));if(fn==='SQRT')return args[0]===null?null:Math.sqrt(Number(args[0]));if(fn==='DECODE'){const v=args[0];for(let i=1;i<args.length-1;i+=2){if(valuesEqual(v,args[i]))return args[i+1];}return args.length%2===0?args[args.length-1]:null;}if(fn==='NVL2'){return args[0]!==null?args[1]:args[2];}if(fn==='NULLIF'){return valuesEqual(args[0],args[1])?null:args[0];}return null;}case'case':{if(e.simple){const sv=evalExpr(e.simple,r);for(const w of e.whens){if(valuesEqual(sv,evalExpr(w.when,r)))return evalExpr(w.then,r);}return e.else?evalExpr(e.else,r):null;}for(const w of e.whens){if(evalExpr(w.when,r)===true)return evalExpr(w.then,r);}return e.else?evalExpr(e.else,r):null;}case'exists':{const res=executeAST(e.query);return res.rows.length>0;}case'subquery':{const res=executeAST(e.query);if(res.rows.length===0)return null;return res.rows[0][res.columns[0]];}}return null;}
function evalExprR(e,r,rc){if(e.type==='column'&&!e.table){for(const c of rc)if(c.toUpperCase()===e.name)return r[c];}return evalExpr(e,r);}
function cmpVals(a,b){if(a===null&&b===null)return 0;if(a===null)return-1;if(b===null)return 1;if(typeof a==='number'&&typeof b==='number')return a-b;const na=Number(a),nb=Number(b);if(!isNaN(na)&&!isNaN(nb))return na-nb;return String(a).localeCompare(String(b));}
function hasAgg(cols){for(const c of cols)if(c.type==='expr'&&exprHasAgg(c.expr))return true;return false;}
function exprHasAgg(e){if(!e)return false;if(e.type==='agg')return true;if(e.type==='binary')return exprHasAgg(e.left)||exprHasAgg(e.right);if(e.type==='unary')return exprHasAgg(e.operand);if(e.type==='func')return e.args.some(a=>exprHasAgg(a));if(e.type==='case'){for(const w of e.whens){if(exprHasAgg(w.when)||exprHasAgg(w.then))return true;}return e.else?exprHasAgg(e.else):false;}return false;}
function exprName(e){if(!e)return'?';if(e.type==='column')return e.name;if(e.type==='literal')return e.value===null?'NULL':String(e.value);if(e.type==='agg')return e.fn+'('+(e.arg.type==='star'?'*':exprName(e.arg))+')';if(e.type==='func')return e.fn+'('+e.args.map(exprName).join(',')+')';if(e.type==='case')return'CASE';if(e.type==='binary')return exprName(e.left)+e.op+exprName(e.right);return'?';}

// ============================================================
// PIPELINE: SCHEMA + JOIN LINES + FLOW STEPS
// ============================================================
function initPipeline() {
  const container = document.getElementById('pipelineTables');
  // Keep svg
  const svg = document.getElementById('pipelineSvg');
  container.innerHTML = '';
  container.appendChild(svg);

  for (const [name, tbl] of Object.entries(DB)) {
    const div = document.createElement('div');
    div.className = 'p-table';
    div.dataset.table = name;
    div.id = 'ptable-' + name;
    let html = `<div class="p-table-name">${name}</div><div class="p-table-cols">`;
    for (const col of tbl.columns) {
      const pk = col === tbl.pk;
      html += `<div class="p-col${pk ? ' p-col-pk' : ''}" data-col="${col}" id="pcol-${name}-${col}">${pk ? 'üîë ' : ''}${col}</div>`;
    }
    html += '</div>';
    div.innerHTML = html;
    container.appendChild(div);
  }
}

function updatePipeline(sql) {
  const tokens = tokenize(sql).filter(t => t.type !== 'ws');
  const allTableNames = new Set(Object.keys(DB));
  const tablesFrom = new Set(), tablesJoin = new Set();
  const joinLinks = [];

  // Pass 1: Build alias map (alias/name ‚Üí real table name)
  const aliasMap = {};
  let cl = '';
  for (let i = 0; i < tokens.length; i++) {
    const t = tokens[i];
    if (t.type !== 'word') continue;
    const w = t.value.toUpperCase();
    if (w === 'FROM') { cl = 'from'; continue; }
    if (['JOIN','INNER','LEFT','RIGHT','FULL','CROSS','NATURAL'].includes(w) && isJoinCtx(tokens, i)) { cl = 'join'; continue; }
    if (['ON','USING','WHERE','GROUP','HAVING','ORDER','SELECT'].includes(w)) { cl = ''; continue; }
    if ((cl === 'from' || cl === 'join') && allTableNames.has(w)) {
      aliasMap[w] = w;
      if (cl === 'from') tablesFrom.add(w); else tablesJoin.add(w);
      if (i + 1 < tokens.length && tokens[i+1].type === 'word') {
        const nw = tokens[i+1].value.toUpperCase();
        if (nw === 'AS' && i + 2 < tokens.length && tokens[i+2].type === 'word') {
          aliasMap[tokens[i+2].value.toUpperCase()] = w;
        } else if (!['ON','USING','WHERE','GROUP','HAVING','ORDER','JOIN','INNER','LEFT','RIGHT','FULL','CROSS','NATURAL'].includes(nw)) {
          aliasMap[nw] = w;
        }
      }
    }
  }
  function res(name) { return aliasMap[name.toUpperCase()] || name.toUpperCase(); }

  // Table-specific column highlights: "TABLE\tCOL" ‚Üí Set<cssClass>
  const colHL = new Map();
  function addHL(table, col, cls) {
    const key = table + '\t' + col;
    if (!colHL.has(key)) colHL.set(key, new Set());
    colHL.get(key).add(cls);
  }

  // Pass 2: detect clauses, columns (table-aware), and join links
  cl = '';
  let lastJoinTable = null;
  for (let i = 0; i < tokens.length; i++) {
    const t = tokens[i];
    if (t.type !== 'word') continue;
    const w = t.value.toUpperCase();

    if (w === 'SELECT' || w === 'DISTINCT') { cl = 'select'; continue; }
    if (w === 'FROM') { cl = 'from'; continue; }
    if (w === 'WHERE') { cl = 'where'; continue; }
    if (['JOIN','INNER','LEFT','RIGHT','FULL','CROSS','NATURAL'].includes(w) && isJoinCtx(tokens, i)) {
      cl = 'join';
      for (let j = i + 1; j < tokens.length; j++) {
        if (tokens[j].type !== 'word') continue;
        const jw = tokens[j].value.toUpperCase();
        if (jw === 'JOIN') continue;
        lastJoinTable = res(jw);
        break;
      }
      continue;
    }
    if (w === 'ON') { cl = 'join_cond'; continue; }
    if (w === 'USING') { cl = 'join_using'; continue; }
    if (w === 'GROUP') { cl = 'group'; continue; }
    if (w === 'HAVING') { cl = 'having'; continue; }
    if (w === 'ORDER') { cl = 'order'; continue; }
    if (['BY','AS','AND','OR','NOT','IN','BETWEEN','LIKE','IS','NULL','ASC','DESC'].includes(w)) continue;
    if (AGG_FN.has(w)) continue;

    // Skip table/alias names in FROM/JOIN context
    if ((cl === 'from' || cl === 'join') && (allTableNames.has(w) || aliasMap[w])) continue;

    // Map clause to CSS class
    const clsMap = { select:'hl-select', where:'hl-where', join_cond:'hl-join-col', join_using:'hl-join-col', group:'hl-group', having:'hl-having', order:'hl-order' };
    const hlCls = clsMap[cl];

    // Check for table.column pattern (table-specific highlighting)
    if (i + 2 < tokens.length && tokens[i+1].type === 'dot' && (tokens[i+2].type === 'word' || tokens[i+2].type === 'star')) {
      const tblName = res(w);
      const colName = tokens[i+2].value.toUpperCase();
      if (colName !== '*' && hlCls) addHL(tblName, colName, hlCls);

      // Detect JOIN ON condition: t1.col = t2.col
      if (cl === 'join_cond' && i + 6 < tokens.length) {
        let j = i + 3;
        if (j < tokens.length && tokens[j].type === 'op' && tokens[j].value === '=') {
          j++;
          if (j + 2 < tokens.length && tokens[j].type === 'word' && tokens[j+1].type === 'dot' && tokens[j+2].type === 'word') {
            const rt = res(tokens[j].value.toUpperCase());
            const rc = tokens[j+2].value.toUpperCase();
            joinLinks.push({ leftTable: tblName, leftCol: colName, rightTable: rt, rightCol: rc });
          }
        }
      }
      i += 2;
      continue;
    }

    // USING columns ‚Üí join link + highlight in both tables
    if (cl === 'join_using') {
      let isCol = false;
      for (const tbl of Object.values(DB)) { if (tbl.columns.includes(w)) { isCol = true; break; } }
      if (isCol) {
        const fromTbls = [...tablesFrom];
        if (fromTbls.length > 0 && lastJoinTable) {
          joinLinks.push({ leftTable: fromTbls[0], leftCol: w, rightTable: lastJoinTable, rightCol: w });
          addHL(fromTbls[0], w, 'hl-join-col');
          addHL(lastJoinTable, w, 'hl-join-col');
        }
      }
      continue;
    }

    // Bare column name ‚Üí highlight in all tables that have it
    if (hlCls) {
      for (const [tblName, tbl] of Object.entries(DB)) {
        if (tbl.columns.includes(w)) addHL(tblName, w, hlCls);
      }
    }
  }

  // When timeline is active, let it control highlights
  if (timelineSteps.length > 0) {
    updatePipelineForStep(timelinePos);
    updateFlowForStep(timelinePos);
    return;
  }

  // Update table highlights
  document.querySelectorAll('.p-table').forEach(el => {
    const n = el.dataset.table;
    el.classList.remove('hl-from', 'hl-join');
    if (tablesFrom.has(n)) el.classList.add('hl-from');
    if (tablesJoin.has(n)) el.classList.add('hl-join');
  });

  // Update column highlights (table-specific!)
  document.querySelectorAll('.p-col').forEach(el => {
    const col = el.dataset.col;
    const table = el.closest('.p-table')?.dataset.table;
    el.classList.remove('hl-select', 'hl-where', 'hl-join-col', 'hl-group', 'hl-having', 'hl-order');
    if (!table) return;
    const key = table + '\t' + col;
    const classes = colHL.get(key);
    if (classes) classes.forEach(c => el.classList.add(c));
  });

  drawJoinLines(joinLinks);
  updateFlow(sql);
}

function drawJoinLines(links) {
  window.__lastLinks = links;
  const svg = document.getElementById('pipelineSvg');
  svg.innerHTML = '';
  const container = document.getElementById('pipelineTables');
  const cRect = container.getBoundingClientRect();
  const isMobile = window.innerWidth <= 768;

  for (const link of links) {
    const leftEl = document.getElementById('pcol-' + link.leftTable + '-' + link.leftCol);
    const rightEl = document.getElementById('pcol-' + link.rightTable + '-' + link.rightCol);
    if (!leftEl || !rightEl) continue;

    const lRect = leftEl.getBoundingClientRect();
    const rRect = rightEl.getBoundingClientRect();

    // Self-join: curved line on the right side
    if (link.leftTable === link.rightTable) {
      const tEl = document.getElementById('ptable-' + link.leftTable);
      if (!tEl) continue;
      const tRect = tEl.getBoundingClientRect();
      const tx = tRect.right - cRect.left + 8;
      const ty1 = lRect.top + lRect.height/2 - cRect.top;
      const ty2 = rRect.top + rRect.height/2 - cRect.top;
      const cx = tx + 30;
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', `M${tx-8},${ty1} C${cx},${ty1} ${cx},${ty2} ${tx-8},${ty2}`);
      path.setAttribute('class', 'join-line join-line-anim');
      svg.appendChild(path);
      continue;
    }

    if (isMobile) {
      // Vertical layout: draw line from right edge of top column to right edge of bottom column
      const topEl = lRect.top <= rRect.top ? lRect : rRect;
      const botEl = lRect.top <= rRect.top ? rRect : lRect;
      const x1 = topEl.right - cRect.left - 12;
      const y1 = topEl.top + topEl.height/2 - cRect.top;
      const x2 = botEl.right - cRect.left - 12;
      const y2 = botEl.top + botEl.height/2 - cRect.top;
      const midY = (y1 + y2) / 2;
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', `M${x1},${y1} C${x1},${midY} ${x2},${midY} ${x2},${y2}`);
      path.setAttribute('class', 'join-line join-line-anim');
      svg.appendChild(path);
      for (const [x, y] of [[x1, y1], [x2, y2]]) {
        const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        dot.setAttribute('cx', x); dot.setAttribute('cy', y);
        dot.setAttribute('class', 'join-dot'); dot.setAttribute('r', '4');
        svg.appendChild(dot);
      }
      continue;
    }

    // Desktop: horizontal layout
    const lCenter = lRect.left + lRect.width / 2;
    const rCenter = rRect.left + rRect.width / 2;
    let x1, y1, x2, y2;
    if (lCenter <= rCenter) {
      x1 = lRect.right - cRect.left;
      y1 = lRect.top + lRect.height/2 - cRect.top;
      x2 = rRect.left - cRect.left;
      y2 = rRect.top + rRect.height/2 - cRect.top;
    } else {
      x1 = rRect.right - cRect.left;
      y1 = rRect.top + rRect.height/2 - cRect.top;
      x2 = lRect.left - cRect.left;
      y2 = lRect.top + lRect.height/2 - cRect.top;
    }

    const midX = (x1 + x2) / 2;
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', `M${x1},${y1} C${midX},${y1} ${midX},${y2} ${x2},${y2}`);
    path.setAttribute('class', 'join-line join-line-anim');
    svg.appendChild(path);

    // Dots at endpoints
    for (const [x, y] of [[x1, y1], [x2, y2]]) {
      const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      dot.setAttribute('cx', x); dot.setAttribute('cy', y);
      dot.setAttribute('class', 'join-dot');
      dot.setAttribute('r', '4');
      svg.appendChild(dot);
    }
  }
}

// ============================================================
// EXECUTION FLOW STEPS
// ============================================================
const FLOW_STEPS = [
  { id: 'from', label: 'FROM', cls: 's-from', desc: 'Urƒçuje zdrojovou tabulku (odkud bereme data)', regex: /\bFROM\b/i },
  { id: 'join', label: 'JOIN', cls: 's-join', desc: 'Spoj√≠ dvƒõ tabulky dohromady podle spoleƒçn√©ho sloupce', regex: /\bJOIN\b/i },
  { id: 'where', label: 'WHERE', cls: 's-where', desc: 'Filtruje ≈ô√°dky ‚Äî zobraz√≠ jen ty, co spl≈àuj√≠ podm√≠nku', regex: /\bWHERE\b/i },
  { id: 'group', label: 'GROUP BY', cls: 's-group', desc: 'Seskup√≠ ≈ô√°dky podle hodnot ‚Äî umo≈æn√≠ agregaci (COUNT, SUM‚Ä¶)', regex: /\bGROUP\s+BY\b/i },
  { id: 'having', label: 'HAVING', cls: 's-having', desc: 'Filtruje skupiny ‚Äî funguje jako WHERE, ale a≈æ po seskupen√≠', regex: /\bHAVING\b/i },
  { id: 'select', label: 'SELECT', cls: 's-select', desc: 'Vybere sloupce, kter√© se zobraz√≠ ve v√Ωsledku', regex: /\bSELECT\b/i },
  { id: 'order', label: 'ORDER BY', cls: 's-order', desc: 'Se≈ôad√≠ v√Ωsledn√© ≈ô√°dky (ASC = vzestupnƒõ, DESC = sestupnƒõ)', regex: /\bORDER\s+BY\b/i },
];

function updateFlow(sql) {
  const bar = document.getElementById('flowBar');
  bar.innerHTML = '<span class="flow-label">Po≈ôad√≠ vykon√°n√≠:</span>';
  let first = true;
  for (const step of FLOW_STEPS) {
    const active = step.regex.test(sql);
    if (!active) continue;
    if (!first) { const arrow = document.createElement('span'); arrow.className = 'flow-arrow'; arrow.textContent = '‚Üí'; bar.appendChild(arrow); }
    first = false;
    const el = document.createElement('span');
    el.className = `flow-step ${step.cls} active`;
    el.textContent = step.label;
    el.onclick = (e) => { e.stopPropagation(); el.classList.toggle('show-tip'); };
    const tip = document.createElement('div');
    tip.className = 'flow-tooltip';
    tip.textContent = step.desc;
    el.appendChild(tip);
    bar.appendChild(el);
  }
}

// Close tooltips on outside click
document.addEventListener('click', () => { document.querySelectorAll('.flow-step').forEach(s => s.classList.remove('show-tip')); });

// ============================================================
// EDITOR
// ============================================================
const textarea = document.getElementById('editorTextarea');
const highlight = document.getElementById('editorHighlight');
const lineNumbers = document.getElementById('lineNumbers');
const clauseWarningEl = document.getElementById('clauseWarning');

// ---- Clause order detection ----
const CLAUSE_ORDER = ['SELECT','FROM','JOIN','WHERE','GROUP BY','HAVING','ORDER BY'];

function checkClauseOrder(sql) {
  if (!sql || !sql.trim()) { clauseWarningEl.classList.remove('visible'); clauseWarningEl.innerHTML = ''; return; }
  // Strip string literals and comments to avoid false positives
  const cleaned = sql.replace(/'[^']*'/g, "''").replace(/"[^"]*"/g, '""').replace(/--[^\n]*/g, '');
  // Find positions of each clause (top-level only ‚Äî skip subqueries in parens)
  const found = [];
  let depth = 0;
  const upper = cleaned.toUpperCase();
  for (let i = 0; i < upper.length; i++) {
    if (upper[i] === '(') { depth++; continue; }
    if (upper[i] === ')') { depth--; continue; }
    if (depth > 0) continue;
    for (const clause of CLAUSE_ORDER) {
      if (upper.startsWith(clause, i)) {
        const before = i === 0 || /\s/.test(upper[i - 1]);
        const after = i + clause.length >= upper.length || /[\s(]/.test(upper[i + clause.length]);
        if (before && after) {
          // For JOIN variants (LEFT JOIN, INNER JOIN etc.) ‚Äî treat as JOIN
          const label = clause === 'JOIN' ? 'JOIN' : clause;
          if (label === 'JOIN' && found.some(f => f.clause === 'JOIN')) continue; // skip duplicate JOINs
          found.push({ clause: label, pos: i });
        }
      }
    }
  }
  // Check order violations
  const warnings = [];
  const orderMap = {};
  CLAUSE_ORDER.forEach((c, idx) => orderMap[c] = idx);
  const hasGroupBy = found.some(f => f.clause === 'GROUP BY');

  for (let i = 1; i < found.length; i++) {
    const prev = found[i - 1], curr = found[i];
    if (orderMap[curr.clause] < orderMap[prev.clause]) {
      warnings.push(`‚ö†Ô∏è ${curr.clause} mus√≠ b√Ωt p≈ôed ${prev.clause} ‚Äî spr√°vn√© po≈ôad√≠: SELECT ‚Üí FROM ‚Üí JOIN ‚Üí WHERE ‚Üí GROUP BY ‚Üí HAVING ‚Üí ORDER BY`);
    }
  }
  // HAVING without GROUP BY
  if (found.some(f => f.clause === 'HAVING') && !hasGroupBy) {
    warnings.push('‚ö†Ô∏è HAVING vy≈æaduje GROUP BY ‚Äî nelze filtrovat skupiny bez seskupen√≠');
  }
  // SELECT not first
  if (found.length > 0 && found[0].clause !== 'SELECT') {
    warnings.push('‚ö†Ô∏è SELECT mus√≠ b√Ωt na zaƒç√°tku dotazu');
  }

  if (warnings.length > 0) {
    clauseWarningEl.innerHTML = warnings.map(w => `<span>${w}</span>`).join('');
    clauseWarningEl.classList.add('visible');
  } else {
    clauseWarningEl.classList.remove('visible');
    clauseWarningEl.innerHTML = '';
  }
}

let clauseCheckTimer = null;

function updateEditor() {
  const fullSql = textarea.value;
  highlight.innerHTML = highlightSQL(fullSql) + '\n';
  // Line numbers
  const lines = fullSql.split('\n').length;
  let ln = '';
  for (let i = 1; i <= lines; i++) ln += i + '\n';
  lineNumbers.textContent = ln;
  // Pipeline + data flow use only the current statement (not full textarea)
  const currentSql = getStatementAtCursor().sql;
  updatePipeline(currentSql);
  if (!isAnimating) updateDataFlow(currentSql);
  // Debounced clause order check
  clearTimeout(clauseCheckTimer);
  clauseCheckTimer = setTimeout(() => checkClauseOrder(currentSql), 500);
}

textarea.addEventListener('input', () => { stopAutoplay(); timelineSteps = []; updateEditor(); });
textarea.addEventListener('scroll', () => {
  highlight.scrollTop = textarea.scrollTop;
  highlight.scrollLeft = textarea.scrollLeft;
  lineNumbers.style.transform = `translateY(-${textarea.scrollTop}px)`;
});

// Animation state
let isAnimating = false, skipAnimation = false, animStartTime = 0;
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

document.addEventListener('keydown', (e) => {
  if (isAnimating && (Date.now() - animStartTime > 200) && !['Control','Shift','Alt','Meta'].includes(e.key)) skipAnimation = true;
});
document.addEventListener('click', () => { if (isAnimating && (Date.now() - animStartTime > 200)) skipAnimation = true; });

textarea.addEventListener('keydown', (e) => {
  if (isAnimating) { e.preventDefault(); return; }
  if (e.key === 'Tab') {
    e.preventDefault();
    const s = textarea.selectionStart, end = textarea.selectionEnd;
    textarea.value = textarea.value.substring(0, s) + '  ' + textarea.value.substring(end);
    textarea.selectionStart = textarea.selectionEnd = s + 2;
    updateEditor();
  }
  if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); executeQuery(); }
});

// ============================================================
// QUERY EXECUTION
// ============================================================
function getStatementAtCursor() {
  const text = textarea.value;
  const cursor = textarea.selectionStart;
  const statements = [];
  let start = 0, inStr = false, strChar = '';
  for (let i = 0; i <= text.length; i++) {
    const ch = text[i];
    if (inStr) { if (ch === strChar) inStr = false; continue; }
    if (ch === "'" || ch === '"') { inStr = true; strChar = ch; continue; }
    if (ch === ';' || i === text.length) {
      const stmt = text.substring(start, i).trim();
      // end includes ';' plus any trailing whitespace/newlines
      let endPos = (ch === ';') ? i + 1 : i;
      while (endPos < text.length && /[\s]/.test(text[endPos])) endPos++;
      if (stmt) statements.push({ sql: stmt, displaySql: stmt + (ch === ';' ? ';' : ''), start, end: endPos });
      start = endPos;
    }
  }
  for (const s of statements) {
    if (cursor >= s.start && cursor < s.end) return s;
    // Cursor exactly at end (after ';') ‚Äî still belongs to this statement
    if (cursor === s.end) return s;
  }
  if (statements.length > 0) return statements[statements.length - 1];
  return { sql: text.trim(), displaySql: text.trim(), start: 0, end: text.length };
}

async function executeQuery() {
  const stmt = getStatementAtCursor();
  const sql = stmt.sql;
  if (!sql) return;
  if (isAnimating) { skipAnimation = true; return; }
  const wrap = document.getElementById('resultsWrap');
  const status = document.getElementById('resultsStatus');
  wrap.innerHTML = '<div class="results-empty" style="color:var(--text3)">Vykon√°v√°m dotaz‚Ä¶</div>';
  status.innerHTML = '';

  // Keep text before and after the selected statement
  const fullText = textarea.value;
  const prefix = fullText.substring(0, stmt.start);
  const suffix = fullText.substring(stmt.end);
  const animText = stmt.displaySql;
  const sep = suffix.trim() ? '\n\n' : '';

  // Typing animation
  isAnimating = true; skipAnimation = false; animStartTime = Date.now();
  stopAutoplay(); timelineSteps = [];
  textarea.value = prefix + sep + suffix; updateEditor();
  textarea.readOnly = true; textarea.style.caretColor = 'transparent';
  for (let i = 0; i < animText.length; i++) {
    if (skipAnimation) break;
    textarea.value = prefix + animText.substring(0, i + 1) + sep + suffix;
    updateEditor();
    await sleep(/\s/.test(animText[i]) ? 8 : 18);
  }
  textarea.value = prefix + animText + sep + suffix;
  // Place cursor inside the animated statement so getStatementAtCursor finds it
  const cursorPos = prefix.length + animText.length;
  textarea.selectionStart = textarea.selectionEnd = cursorPos;
  textarea.readOnly = false; textarea.style.caretColor = '';
  isAnimating = false; skipAnimation = false;
  updateEditor();

  // Execute
  const t0 = performance.now();
  try {
    const ast = parseSQL(sql);
    const result = executeAST(ast);
    const ms = Math.round(performance.now() - t0);
    if (result.rows.length === 0) {
      let html = '<table class="results-table"><thead><tr>';
      for (const c of result.columns) html += `<th>${escapeHTML(c)}</th>`;
      html += '</tr></thead></table><div class="results-empty" style="border-top:none;padding-top:8px">Dotaz vr√°til 0 ≈ô√°dk≈Ø</div>';
      wrap.innerHTML = html;
      status.innerHTML = `<span>0 ≈ô√°dk≈Ø</span><span>${result.columns.length} sl.</span><span>${ms} ms</span>`;
    } else {
      let html = '<table class="results-table"><thead><tr>';
      for (const c of result.columns) html += `<th>${escapeHTML(c)}</th>`;
      html += '</tr></thead><tbody>';
      for (let i = 0; i < result.rows.length; i++) {
        const row = result.rows[i];
        html += `<tr class="row-animate" style="animation-delay:${i*25}ms">`;
        for (const c of result.columns) {
          const v = row[c];
          if (v === null || v === undefined) html += '<td class="cell-null">NULL</td>';
          else if (typeof v === 'number') html += `<td class="cell-number">${v}</td>`;
          else html += `<td class="cell-string">${escapeHTML(String(v))}</td>`;
        }
        html += '</tr>';
      }
      html += '</tbody></table>';
      wrap.innerHTML = html;
      status.innerHTML = `<span>${result.rows.length} ≈ô√°dk≈Ø</span><span>${result.columns.length} sl.</span><span>${ms} ms</span>`;
    }
  } catch (err) {
    const ms = Math.round(performance.now() - t0);
    wrap.innerHTML = `<div class="results-error">Chyba: ${escapeHTML(err.message)}</div>`;
    status.innerHTML = `<span style="color:var(--red)">Chyba</span><span>${ms} ms</span>`;
  }
  checkChallenge();
  // Auto-check tasks if panel has solutions loaded
  try {
    const ast2 = parseSQL(sql);
    const res2 = executeAST(ast2);
    autoCheckTasksWithResult(res2);
  } catch(e) {}
}

function executeInstant(sql) {
  if (isAnimating) { skipAnimation = true; }
  stopAutoplay(); timelineSteps = [];
  textarea.value = sql;
  updateEditor(); // pipeline + data flow (sets timelineSteps, slider to max)

  // Execute and show results
  const wrap = document.getElementById('resultsWrap');
  const status = document.getElementById('resultsStatus');
  const t0 = performance.now();
  try {
    const ast = parseSQL(sql);
    const result = executeAST(ast);
    const ms = Math.round(performance.now() - t0);
    if (result.rows.length === 0) {
      let html = '<table class="results-table"><thead><tr>';
      for (const c of result.columns) html += `<th>${escapeHTML(c)}</th>`;
      html += '</tr></thead></table><div class="results-empty" style="border-top:none;padding-top:8px">Dotaz vr√°til 0 ≈ô√°dk≈Ø</div>';
      wrap.innerHTML = html;
      status.innerHTML = `<span>0 ≈ô√°dk≈Ø</span><span>${result.columns.length} sl.</span><span>${ms} ms</span>`;
    }
    else {
      let html = '<table class="results-table"><thead><tr>';
      for (const c of result.columns) html += `<th>${escapeHTML(c)}</th>`;
      html += '</tr></thead><tbody>';
      for (let i = 0; i < result.rows.length; i++) {
        const row = result.rows[i];
        html += '<tr>';
        for (const c of result.columns) {
          const v = row[c];
          if (v === null || v === undefined) html += '<td class="cell-null">NULL</td>';
          else if (typeof v === 'number') html += `<td class="cell-number">${v}</td>`;
          else html += `<td class="cell-string">${escapeHTML(String(v))}</td>`;
        }
        html += '</tr>';
      }
      html += '</tbody></table>';
      wrap.innerHTML = html;
      status.innerHTML = `<span>${result.rows.length} ≈ô√°dk≈Ø</span><span>${result.columns.length} sl.</span><span>${ms} ms</span>`;
    }
  } catch (err) {
    wrap.innerHTML = `<div class="results-error">Chyba: ${escapeHTML(err.message)}</div>`;
    status.innerHTML = `<span style="color:var(--red)">Chyba</span>`;
  }
  checkChallenge();
}

// ============================================================
// CHALLENGE MODE
// ============================================================
const CHALLENGES = [
  {
    id: 1, title: 'Z√°kladn√≠ filtr',
    from: 'Pavel K≈ô√≠≈æ, CFO',
    text: 'Pot≈ôebuji seznam v≈°ech zamƒõstnanc≈Ø s platem nad 10 000 Kƒç. V√Ωstup: sloupce JMENO, FCE, PLAT. Se≈ôaƒè od nejvy≈°≈°√≠ho platu.',
    hint: 'SELECT + WHERE + ORDER BY',
    solution: "SELECT jmeno, fce, plat FROM zam WHERE plat > 10000 ORDER BY plat DESC"
  },
  {
    id: 2, title: 'JOIN report',
    from: 'Martina Hor√°kov√°, HR',
    text: 'P≈ôiprav report zamƒõstnanc≈Ø z oddƒõlen√≠ PROGRAMOVANI s titulem ING. Pot≈ôebuji sloupce: JMENO, PLAT a NAZEV oddƒõlen√≠ (tabulka ODDEL).',
    hint: 'JOIN + WHERE',
    solution: "SELECT jmeno, plat, nazev FROM zam JOIN oddel USING (cis_odd) WHERE nazev = 'PROGRAMOVANI' AND titul = 'ING'"
  },
  {
    id: 3, title: 'Agregace',
    from: 'Tom√°≈° Bene≈°, Operations',
    text: 'Kolik zamƒõstnanc≈Ø m√° ka≈æd√© oddƒõlen√≠? Zobraz CIS_ODD a poƒçet. Se≈ôaƒè sestupnƒõ podle poƒçtu.',
    hint: 'GROUP BY + COUNT + ORDER BY',
    solution: "SELECT cis_odd, COUNT(*) AS pocet FROM zam GROUP BY cis_odd ORDER BY pocet DESC"
  },
  {
    id: 4, title: 'HAVING filtr',
    from: 'Lucie Dvo≈ô√°kov√°, CEO',
    text: 'Kter√° oddƒõlen√≠ maj√≠ pr≈Ømƒõrn√Ω plat nad 9000 Kƒç? Zobraz NAZEV oddƒõlen√≠ a pr≈Ømƒõrn√Ω plat zaokrouhlen√Ω na cel√° ƒç√≠sla.',
    hint: 'JOIN + GROUP BY + HAVING + ROUND',
    solution: "SELECT nazev, ROUND(AVG(plat), 0) AS prumer FROM oddel JOIN zam USING (cis_odd) GROUP BY nazev HAVING AVG(plat) > 9000"
  },
  {
    id: 5, title: 'CASE kategorizace',
    from: 'Jana Nov√°kov√°, HR Manager',
    text: 'Veden√≠ pot≈ôebuje p≈ôehled zamƒõstnanc≈Ø s kategorizac√≠ plat≈Ø: nad 12000 = \'vysoka\', nad 8000 = \'stredni\', zbytek = \'nizka\'. Zobraz JMENO, PLAT a kategorii.',
    hint: 'CASE WHEN + THEN + ELSE',
    solution: "SELECT jmeno, plat, CASE WHEN plat >= 12000 THEN 'vysoka' WHEN plat >= 8000 THEN 'stredni' ELSE 'nizka' END AS kategorie FROM zam"
  },
  {
    id: 6, title: 'Vno≈ôen√Ω dotaz',
    from: 'Karel Svoboda, Analytik',
    text: 'Kte≈ô√≠ zamƒõstnanci maj√≠ plat vy≈°≈°√≠ ne≈æ pr≈Ømƒõr cel√© firmy? Zobraz JMENO a PLAT.',
    hint: 'SELECT + WHERE + vno≈ôen√Ω SELECT',
    solution: "SELECT jmeno, plat FROM zam WHERE plat > (SELECT AVG(plat) FROM zam)"
  }
];

var activeChallengeIdx = -1;
const challengeSolved = new Set();

function toggleChallenge() {
  const panel = document.getElementById('challengePanel');
  const btn = document.getElementById('btnChallenge');
  if (panel.style.display === 'none') {
    if (activeChallengeIdx < 0) activeChallengeIdx = 0;
    loadChallenge(activeChallengeIdx);
    panel.style.display = '';
    btn.classList.add('active');
  } else {
    closeChallenge();
  }
}

function closeChallenge() {
  document.getElementById('challengePanel').style.display = 'none';
  document.getElementById('btnChallenge').classList.remove('active');
  activeChallengeIdx = -1;
  document.getElementById('challengeResult').style.display = 'none';
}

function loadChallenge(idx) {
  const ch = CHALLENGES[idx];
  activeChallengeIdx = idx;
  document.getElementById('challengeTag').textContent = 'CHALLENGE #' + ch.id;
  document.getElementById('challengeFrom').textContent = 'Od: ' + ch.from;
  document.getElementById('challengeBody').textContent = ch.text;
  document.getElementById('challengeHint').textContent = 'N√°povƒõda: ' + ch.hint;
  document.getElementById('challengeCounter').innerHTML =
    (idx + 1) + ' / ' + CHALLENGES.length + (challengeSolved.has(idx) ? '<span class="challenge-done"> ‚úì</span>' : '');
  document.getElementById('chPrev').disabled = idx === 0;
  document.getElementById('chNext').disabled = idx === CHALLENGES.length - 1;
  document.getElementById('challengeResult').style.display = 'none';
}

function prevChallenge() { if (activeChallengeIdx > 0) loadChallenge(activeChallengeIdx - 1); }
function nextChallenge() { if (activeChallengeIdx < CHALLENGES.length - 1) loadChallenge(activeChallengeIdx + 1); }

function compareResults(exp, act) {
  // exp can be either a result object {rows, columns} or precomputed {data: [[...],...]
  // Positional comparison ‚Äî ignores column names, only values matter
  // This means JOIN and subquery solutions both pass if they return same data
  if (exp.rows.length !== act.rows.length) return false;
  if (exp.columns.length !== act.columns.length) return false;
  // Normalize: sort rows, uppercase strings, null‚Üí''
  const normRow = (row, cols) =>
    cols.map(c => { const v = row[c]; return v === null || v === undefined ? '' : String(v).toUpperCase().trim(); });
  const normData = (rows, cols) =>
    rows.map(r => normRow(r, cols)).sort((a, b) => a.join('\x00').localeCompare(b.join('\x00')));
  const eNorm = normData(exp.rows, exp.columns);
  const aNorm = normData(act.rows, act.columns);
  for (let i = 0; i < eNorm.length; i++) {
    for (let j = 0; j < eNorm[i].length; j++) {
      if (eNorm[i][j] !== aNorm[i][j]) return false;
    }
  }
  return true;
}

// Compare student result against precomputed expected data (array of value arrays)
function compareResultsWithData(expectedData, act) {
  // expectedData: [[val, val, ...], ...] ‚Äî rows of values, order-independent
  if (expectedData.length !== act.rows.length) return false;
  if (expectedData.length === 0) return true;
  if (expectedData[0].length !== act.columns.length) return false;
  const norm = v => v === null || v === undefined ? '' : String(v).toUpperCase().trim();
  const sortKey = row => row.map(norm).join('\x00');
  const expSorted = expectedData.map(row => row.map(norm)).sort((a, b) => sortKey(a).localeCompare(sortKey(b)));
  const actSorted = act.rows.map(r => act.columns.map(c => norm(r[c]))).sort((a, b) => sortKey(a).localeCompare(sortKey(b)));
  for (let i = 0; i < expSorted.length; i++) {
    for (let j = 0; j < expSorted[i].length; j++) {
      if (expSorted[i][j] !== actSorted[i][j]) return false;
    }
  }
  return true;
}

function checkChallenge() {
  if (activeChallengeIdx < 0) return;
  const ch = CHALLENGES[activeChallengeIdx];
  const userSQL = getStatementAtCursor().sql;
  if (!userSQL) return;

  // Hide previous result before re-checking
  document.getElementById('challengeResult').style.display = 'none';

  let actual;
  try {
    actual = executeAST(parseSQL(userSQL));
  } catch (e) {
    // User's SQL has a syntax/execution error ‚Äî don't show challenge fail,
    // the error is already visible in the results panel
    return;
  }

  try {
    const expected = executeAST(parseSQL(ch.solution));
    if (compareResults(expected, actual)) {
      showChallengeSuccess();
    } else {
      showChallengeFail();
    }
  } catch (e) {
    // Solution itself failed ‚Äî shouldn't happen
  }
}

function showChallengeSuccess() {
  challengeSolved.add(activeChallengeIdx);
  const res = document.getElementById('challengeResult');
  res.className = 'challenge-result success';
  res.textContent = 'Challenge splnƒõna! ‚úì';
  res.style.display = '';
  // Update counter to show checkmark
  const idx = activeChallengeIdx;
  document.getElementById('challengeCounter').innerHTML =
    (idx + 1) + ' / ' + CHALLENGES.length + '<span class="challenge-done"> ‚úì</span>';

  // Green flash
  const flash = document.createElement('div');
  flash.className = 'challenge-flash';
  document.body.appendChild(flash);
  setTimeout(() => flash.remove(), 700);

  // Confetti
  const colors = ['#3fb950', '#58a6ff', '#bc8cff', '#f778ba', '#d29922', '#ff7b72', '#79c0ff'];
  const count = window.innerWidth <= 768 ? 15 : 30;
  for (let i = 0; i < count; i++) {
    const piece = document.createElement('div');
    piece.className = 'confetti-piece';
    piece.style.left = Math.random() * 100 + 'vw';
    piece.style.background = colors[Math.floor(Math.random() * colors.length)];
    piece.style.animationDelay = (Math.random() * 0.5) + 's';
    piece.style.animationDuration = (1.2 + Math.random() * 1) + 's';
    document.body.appendChild(piece);
    setTimeout(() => piece.remove(), 2500);
  }
}

function showChallengeFail() {
  const res = document.getElementById('challengeResult');
  res.className = 'challenge-result fail';
  res.textContent = 'V√Ωsledek nesed√≠, zkus to znovu';
  res.style.display = '';
}

// ============================================================
// SQL DICTIONARY
// ============================================================
const DICT_ENTRIES = [
  { kw: 'SELECT', tag: 'blue', desc: 'Vyb√≠r√° sloupce k zobrazen√≠.', ex: 'SELECT jmeno, plat FROM zam;' },
  { kw: 'DISTINCT', tag: 'blue', desc: 'Odstran√≠ duplicitn√≠ ≈ô√°dky z v√Ωsledku.', ex: 'SELECT DISTINCT cis_odd FROM zam;' },
  { kw: 'FROM', tag: 'green', desc: 'Urƒçuje zdrojovou tabulku (nebo tabulky).', ex: 'SELECT * FROM zam;' },
  { kw: 'WHERE', tag: 'yellow', desc: 'Filtruje ≈ô√°dky podle podm√≠nky. Vyhodnocuje se p≈ôed agregac√≠.', ex: 'WHERE plat > 10000' },
  { kw: 'JOIN', tag: 'purple', desc: 'Propojuje dvƒõ tabulky p≈ôes spoleƒçn√Ω kl√≠ƒç. Typy: INNER, LEFT, RIGHT, FULL, CROSS.', ex: 'JOIN oddel ON zam.cis_odd = oddel.cis_odd' },
  { kw: 'ON / USING', tag: 'purple', desc: 'Definuje podm√≠nku propojen√≠ tabulek. USING pro stejnojmenn√© sloupce.', ex: 'JOIN oddel USING (cis_odd)' },
  { kw: 'GROUP BY', tag: 'pink', desc: 'Seskupuje ≈ô√°dky se stejn√Ωmi hodnotami pro pou≈æit√≠ agregaƒçn√≠ch funkc√≠.', ex: 'GROUP BY cis_odd' },
  { kw: 'HAVING', tag: 'red', desc: 'Filtruje skupiny po agregaci. Pou≈æ√≠v√° se s GROUP BY.', ex: 'HAVING COUNT(*) >= 2' },
  { kw: 'ORDER BY', tag: 'cyan', desc: '≈òad√≠ v√Ωsledek vzestupnƒõ (ASC) nebo sestupnƒõ (DESC).', ex: 'ORDER BY plat DESC' },
  { kw: 'AS', tag: 'blue', desc: 'P≈ôejmenuje sloupec nebo tabulku (alias). Nepovinn√© slovo.', ex: 'SELECT jmeno AS zamestnanec' },
  { kw: 'COUNT()', tag: 'orange', desc: 'Poƒç√≠t√° ≈ô√°dky nebo nepr√°zdn√© hodnoty ve skupinƒõ.', ex: 'SELECT COUNT(*) FROM zam;' },
  { kw: 'SUM() / AVG()', tag: 'orange', desc: 'SUM seƒçte hodnoty, AVG vypoƒç√≠t√° pr≈Ømƒõr.', ex: 'SELECT AVG(plat) FROM zam;' },
  { kw: 'MIN() / MAX()', tag: 'orange', desc: 'Najde nejmen≈°√≠ / nejvƒõt≈°√≠ hodnotu ve skupinƒõ.', ex: 'SELECT MAX(plat) FROM zam;' },
  { kw: 'IS NULL', tag: 'yellow', desc: 'Kontroluje, zda je hodnota pr√°zdn√° (NULL). IS NOT NULL = nen√≠ pr√°zdn√°.', ex: 'WHERE titul IS NOT NULL' },
  { kw: 'LIKE', tag: 'yellow', desc: 'Hled√° vzor v textu. % = libovoln√Ω ≈ôetƒõzec, _ = jeden znak.', ex: "WHERE jmeno LIKE '%OVA'" },
  { kw: 'BETWEEN', tag: 'yellow', desc: 'Testuje, zda hodnota le≈æ√≠ v rozsahu (vƒçetnƒõ krajn√≠ch hodnot).', ex: 'WHERE plat BETWEEN 8000 AND 12000' },
  { kw: 'IN', tag: 'yellow', desc: 'Testuje, zda hodnota odpov√≠d√° nƒõkter√© z vyjmenovan√Ωch.', ex: "WHERE fce IN ('ANALYTIK', 'PROGRAMATOR')" },
  { kw: 'CASE WHEN', tag: 'orange', desc: 'Podm√≠nƒõn√Ω v√Ωraz ‚Äî obdoba IF/ELSE v SQL.', ex: "CASE WHEN plat > 10000 THEN 'vysoky' ELSE 'nizky' END" },
  { kw: 'NVL()', tag: 'orange', desc: 'Nahrad√≠ NULL zadanou hodnotou (Oracle funkce).', ex: "NVL(titul, 'bez titulu')" },
  { kw: 'ROUND()', tag: 'orange', desc: 'Zaokrouhl√≠ ƒç√≠slo na dan√Ω poƒçet desetinn√Ωch m√≠st.', ex: 'ROUND(AVG(plat), 2)' },
  { kw: 'UNION', tag: 'blue', desc: 'Spoj√≠ v√Ωsledky dvou SELECT≈Ø. UNION ALL zachov√° duplicity.', ex: 'SELECT ... UNION SELECT ...' },
  { kw: 'EXISTS', tag: 'yellow', desc: 'Vrac√≠ TRUE pokud vno≈ôen√Ω dotaz vr√°t√≠ alespo≈à jeden ≈ô√°dek.', ex: 'WHERE EXISTS (SELECT 1 FROM ...)' },
  { kw: 'ROWNUM', tag: 'orange', desc: 'Pseudo-sloupec ‚Äî po≈ôadov√© ƒç√≠slo ≈ô√°dku (Oracle).', ex: 'WHERE ROWNUM <= 5' },
];

function initDict() {
  const list = document.getElementById('dictList');
  let html = '';
  for (const e of DICT_ENTRIES) {
    html += `<div class="dict-item">`;
    html += `<div class="dict-kw"><span class="dict-tag dict-tag-${e.tag}">${escapeHTML(e.kw)}</span></div>`;
    html += `<div class="dict-desc">${escapeHTML(e.desc)}</div>`;
    html += `<div class="dict-example">${escapeHTML(e.ex)}</div>`;
    html += `</div>`;
  }
  list.innerHTML = html;
}

function toggleDict() {
  const panel = document.getElementById('dictPanel');
  const btn = document.getElementById('btnDict');
  if (panel.style.display === 'none') {
    panel.style.display = '';
    btn.classList.add('active');
  } else {
    panel.style.display = 'none';
    btn.classList.remove('active');
  }
}

// ============================================================
// EXAMPLES
// ============================================================
const EXAMPLES = [
  { name: 'Z√°kladn√≠ SELECT', sql: "SELECT jmeno, fce\nFROM zam;" },
  { name: 'WHERE IS NOT NULL', sql: "SELECT jmeno, fce, titul\nFROM zam\nWHERE titul IS NOT NULL;" },
  { name: 'WHERE LIKE', sql: "SELECT jmeno, fce\nFROM zam\nWHERE jmeno LIKE '%OVA';" },
  { name: 'Concatenace', sql: "SELECT 'Pan ' || jmeno || ' pracuje v odd. ƒç. ' || cis_odd AS info\nFROM zam;" },
  { name: 'JOIN ON', sql: "SELECT z.jmeno, z.fce, o.nazev\nFROM zam z\nJOIN oddel o ON z.cis_odd = o.cis_odd;" },
  { name: 'JOIN USING', sql: "SELECT z.jmeno, u.popis, u.datum\nFROM zam z\nJOIN ukoly u USING (os_cis);" },
  { name: 'GROUP BY + COUNT', sql: "SELECT cis_odd, COUNT(*) AS pocet\nFROM zam\nWHERE titul IS NULL\nGROUP BY cis_odd;" },
  { name: 'HAVING', sql: "SELECT os_cis, COUNT(*) AS pocet_ukolu\nFROM ukoly\nGROUP BY os_cis\nHAVING COUNT(*) >= 2;" },
  { name: 'ORDER BY', sql: "SELECT jmeno, cis_odd, plat\nFROM zam\nORDER BY cis_odd ASC, plat DESC;" },
  { name: 'Self JOIN', sql: "SELECT z.jmeno AS zamestnanec, n.jmeno AS nadrizeny\nFROM zam z\nJOIN zam n ON z.nadr = n.os_cis;" },
  { name: 'Agregace', sql: "SELECT cis_odd,\n  AVG(plat) AS prumerny_plat,\n  MAX(plat) AS max_plat,\n  MIN(plat) AS min_plat\nFROM zam\nGROUP BY cis_odd;" },
  { name: 'Vno≈ôen√Ω dotaz', sql: "SELECT jmeno, plat\nFROM zam\nWHERE plat > (SELECT AVG(plat) FROM zam);" },
  { name: 'ROUND + AVG', sql: "SELECT cis_odd,\n  ROUND(AVG(plat), 2) AS prumer,\n  ROUND(AVG(plat) * 12, 2) AS rocni_plat\nFROM zam\nGROUP BY cis_odd;" },
  { name: 'RIGHT JOIN', sql: "SELECT oddel.nazev, jmeno\nFROM zam\nRIGHT JOIN oddel ON oddel.sef = zam.os_cis;" },
  { name: 'JOIN + GROUP BY + HAVING', sql: "SELECT oddel.nazev\nFROM oddel\nJOIN zam USING (cis_odd)\nGROUP BY oddel.nazev\nHAVING COUNT(zam.titul) >= 2;" },
  { name: 'CASE WHEN', sql: "SELECT jmeno, plat,\n  CASE\n    WHEN plat >= 12000 THEN 'vysoka'\n    WHEN plat >= 8000 THEN 'stredni'\n    ELSE 'nizka'\n  END AS kategorie\nFROM zam;" },
  { name: 'UNION', sql: "SELECT jmeno, fce FROM zam WHERE cis_odd = 1\nUNION\nSELECT jmeno, fce FROM zam WHERE plat > 10000;" },
  { name: 'EXISTS', sql: "SELECT jmeno, fce\nFROM zam z\nWHERE EXISTS (\n  SELECT 1 FROM ukoly u\n  WHERE u.os_cis = z.os_cis\n);" },
  { name: 'ROWNUM', sql: "SELECT jmeno, plat, ROWNUM\nFROM zam\nWHERE ROWNUM <= 5;" },
  { name: 'NVL + NVL2', sql: "SELECT jmeno,\n  NVL(titul, 'bez titulu') AS titul,\n  NVL2(titul, 'ma titul', 'nema') AS stav\nFROM zam;" },
];

function initExamples() {
  const menu = document.getElementById('examplesMenu');
  EXAMPLES.forEach((ex, i) => {
    const item = document.createElement('div');
    item.className = 'example-item';
    item.innerHTML = `<span class="example-num">${i+1}.</span><div class="example-info"><div class="example-name">${escapeHTML(ex.name)}</div><div class="example-sql">${escapeHTML(ex.sql.replace(/\n/g,' '))}</div></div>`;
    item.onclick = () => { textarea.value = ex.sql; toggleExamples(); executeInstant(ex.sql); };
    menu.appendChild(item);
  });
}
function toggleExamples() { document.getElementById('examplesMenu').classList.toggle('show'); }
document.addEventListener('click', (e) => { if (!e.target.closest('.examples-dropdown')) document.getElementById('examplesMenu').classList.remove('show'); });

// ============================================================
// RESIZE HANDLES (generic)
// ============================================================
function initResize(handleEl, topEl, bottomEl, minTop, minBottom) {
  let active = false;
  handleEl.addEventListener('mousedown', () => { active = true; handleEl.classList.add('dragging'); document.body.style.cursor = 'row-resize'; document.body.style.userSelect = 'none'; });
  document.addEventListener('mousemove', (e) => {
    if (!active) return;
    const appRect = document.querySelector('.app').getBoundingClientRect();
    const topOffset = topEl.getBoundingClientRect().top - appRect.top;
    const bottomEnd = bottomEl.getBoundingClientRect().bottom - appRect.top;
    const y = e.clientY - appRect.top;
    const newTopH = Math.max(minTop, y - topOffset - 2);
    const newBottomH = Math.max(minBottom, bottomEnd - y - 2);
    topEl.style.flex = 'none'; topEl.style.height = newTopH + 'px';
    bottomEl.style.flex = 'none'; bottomEl.style.height = newBottomH + 'px';
    updateEditor();
    drawJoinLines(window.__lastLinks || []);
  });
  document.addEventListener('mouseup', () => { if (active) { active = false; handleEl.classList.remove('dragging'); document.body.style.cursor = ''; document.body.style.userSelect = ''; } });
}
initResize(document.getElementById('resizeEditorFlow'), document.getElementById('editorSection'), document.getElementById('dataflowSection'), 60, 80);
initResize(document.getElementById('resizePipelineResults'), document.getElementById('pipelineSection'), document.getElementById('resultsSection'), 100, 80);

// Column resize (horizontal)
(function() {
  const handle = document.getElementById('resizeColumns');
  const left = document.getElementById('colLeft');
  const right = document.getElementById('colRight');
  let active = false;
  handle.addEventListener('mousedown', () => { active = true; handle.classList.add('dragging'); document.body.style.cursor = 'col-resize'; document.body.style.userSelect = 'none'; });
  document.addEventListener('mousemove', (e) => {
    if (!active) return;
    const parent = left.parentElement.getBoundingClientRect();
    const x = e.clientX - parent.left;
    const newLeftW = Math.max(280, Math.min(x - 2, parent.width - 284));
    left.style.width = newLeftW + 'px';
    right.style.flex = '1';
    updateEditor();
    drawJoinLines(window.__lastLinks || []);
  });
  document.addEventListener('mouseup', () => { if (active) { active = false; handle.classList.remove('dragging'); document.body.style.cursor = ''; document.body.style.userSelect = ''; } });
})();

window.addEventListener('resize', () => { updateEditor(); drawJoinLines(window.__lastLinks || []); });

// ============================================================
// HELPERS FOR DATA FLOW
// ============================================================
function extractClauses(sql) {
  const tokens = tokenize(sql);
  const clauses = {};
  const KW_ORDER = ['SELECT','FROM','JOIN','LEFT','RIGHT','FULL','INNER','CROSS','NATURAL','WHERE','GROUP','HAVING','ORDER'];
  let depth = 0;
  const boundaries = [];
  for (let i = 0; i < tokens.length; i++) {
    const t = tokens[i];
    if (t.type === 'paren_open') depth++;
    if (t.type === 'paren_close') depth--;
    if (depth === 0 && t.type === 'word' && KW_ORDER.includes(t.value.toUpperCase())) {
      const kw = t.value.toUpperCase();
      // JOIN variants: combine LEFT/RIGHT/FULL/INNER/CROSS/NATURAL with JOIN
      if (['LEFT','RIGHT','FULL','INNER','CROSS','NATURAL'].includes(kw)) {
        boundaries.push({ kw: 'JOIN', pos: t.pos });
      } else if (kw === 'GROUP' || kw === 'ORDER') {
        // GROUP BY / ORDER BY ‚Äî skip the BY
        boundaries.push({ kw: kw + ' BY', pos: t.pos });
      } else {
        boundaries.push({ kw, pos: t.pos });
      }
    }
  }
  // Extract text between boundaries
  for (let i = 0; i < boundaries.length; i++) {
    const start = boundaries[i].pos;
    const end = i + 1 < boundaries.length ? boundaries[i + 1].pos : sql.length;
    const text = sql.slice(start, end).trim().replace(/\s+/g, ' ');
    const kw = boundaries[i].kw;
    if (clauses[kw]) {
      if (!Array.isArray(clauses[kw])) clauses[kw] = [clauses[kw]];
      clauses[kw].push(text);
    } else {
      clauses[kw] = text;
    }
  }
  return clauses;
}
function collectColumns(expr) {
  const cols = new Set();
  (function walk(e) {
    if (!e) return;
    if (e.type === 'column') { cols.add(e.name); return; }
    if (e.type === 'binary') { walk(e.left); walk(e.right); return; }
    if (e.type === 'unary') { walk(e.operand); return; }
    if (e.type === 'agg') { walk(e.arg); return; }
    if (e.type === 'func') { e.args.forEach(walk); return; }
    if (e.type === 'case') { for(const w of e.whens){walk(w.when);walk(w.then);} if(e.else)walk(e.else); if(e.simple)walk(e.simple); return; }
    if (e.type === 'is_null') { walk(e.expr); return; }
    if (e.type === 'between') { walk(e.expr); walk(e.low); walk(e.high); return; }
    if (e.type === 'like') { walk(e.expr); return; }
    if (e.type === 'in') { walk(e.expr); if (e.values) e.values.forEach(walk); return; }
    if (e.type === 'star') return;
  })(expr);
  return cols;
}

// ============================================================
// STEPPED EXECUTOR (before/after for each SQL clause)
// ============================================================
function executeASTSteppedQuery(query, sqlText) {
  const steps = [];
  let rows = [];
  const aliasMap = {};
  const MAX_PREVIEW = 2;

  // Helper: get display columns from rows (skip internal keys)
  function displayCols(rs) {
    if (rs.length === 0) return [];
    const cols = [];
    for (const k of Object.keys(rs[0])) { if (k !== '__group__' && !k.includes('.')) cols.push(k); }
    return cols;
  }
  function snapshot(rs) { const c = displayCols(rs); return { columns: c, rows: rs.slice(0, MAX_PREVIEW), total: rs.length }; }
  const clauses = sqlText ? extractClauses(sqlText) : {};
  let joinIdx = 0;

  // Helper: build colHL entries for a set of columns with a CSS class
  function buildColHL(activeCols, cssClass) {
    const m = new Map();
    for (const col of activeCols) {
      // Find which tables have this column
      for (const [tblName, tbl] of Object.entries(DB)) {
        if (tbl.columns.includes(col)) {
          const key = tblName + '\t' + col;
          if (!m.has(key)) m.set(key, new Set());
          m.get(key).add(cssClass);
        }
      }
    }
    return m;
  }
  // Helper: build colHL from expression with table-awareness via aliasMap
  function buildColHLFromExpr(expr, cssClass) {
    const m = new Map();
    const cols = [];
    (function walk(e) {
      if (!e) return;
      if (e.type === 'column') { cols.push({ table: e.table, name: e.name }); return; }
      if (e.type === 'binary') { walk(e.left); walk(e.right); return; }
      if (e.type === 'unary') { walk(e.operand); return; }
      if (e.type === 'agg') { walk(e.arg); return; }
      if (e.type === 'func') { e.args.forEach(walk); return; }
      if (e.type === 'case') { for(const w of e.whens){walk(w.when);walk(w.then);} if(e.else)walk(e.else); if(e.simple)walk(e.simple); return; }
      if (e.type === 'is_null') { walk(e.expr); return; }
      if (e.type === 'between') { walk(e.expr); walk(e.low); walk(e.high); return; }
      if (e.type === 'like') { walk(e.expr); return; }
      if (e.type === 'in') { walk(e.expr); if (e.values) e.values.forEach(walk); return; }
    })(expr);
    for (const c of cols) {
      if (c.table) {
        const realTbl = aliasMap[c.table] || c.table;
        const key = realTbl + '\t' + c.name;
        if (!m.has(key)) m.set(key, new Set());
        m.get(key).add(cssClass);
      } else {
        for (const [tblName, tbl] of Object.entries(DB)) {
          if (tbl.columns.includes(c.name)) {
            const key = tblName + '\t' + c.name;
            if (!m.has(key)) m.set(key, new Set());
            m.get(key).add(cssClass);
          }
        }
      }
    }
    return m;
  }

  // FROM
  if (query.from.length === 0) { rows = [{}]; }
  else if (query.from.length === 1) {
    const src = query.from[0];
    if (src.type === 'subquery') { const sr = executeAST(src.query); rows = sr.rows.map(r => { const row = {}; for (const [k,v] of Object.entries(r)) { if (src.alias) row[src.alias.toUpperCase()+'.'+k] = v; row[k] = v; } return row; }); if (src.alias) aliasMap[src.alias.toUpperCase()] = '__subquery__'; }
    else { const tbl = getTable(src.name); rows = tbl.rows.map(r => { const row = {}; for (const col of tbl.columns) { row[col]=r[col]; row[src.name+'.'+col]=r[col]; if(src.alias) row[src.alias+'.'+col]=r[col]; } return row; }); aliasMap[src.name]=src.name; if(src.alias) aliasMap[src.alias]=src.name; }
  } else {
    rows = [{}];
    for (const src of query.from) { const tbl=getTable(src.name); const nr=[]; for(const ex of rows){for(const r of tbl.rows){const row={...ex};for(const col of tbl.columns){row[col]=r[col];row[src.name+'.'+col]=r[col];if(src.alias)row[src.alias+'.'+col]=r[col];}nr.push(row);}} rows=nr; aliasMap[src.name]=src.name; if(src.alias) aliasMap[src.alias]=src.name; }
  }
  if (query.from.length > 0) {
    const fromTables = new Set(query.from.filter(f => f.type !== 'subquery').map(f => f.name.toUpperCase()));
    steps.push({ step: 'from', label: clauses['FROM'] || 'FROM', before: null, after: snapshot(rows), activeCols: new Set(),
      hlInfo: { tablesFrom: fromTables, tablesJoin: new Set(), colHL: new Map(), joinLinks: [] } });
  }

  // JOINs
  for (const join of query.joins) {
    const beforeRows = rows;
    const tbl=getTable(join.table); const ta=join.alias||join.table; aliasMap[join.table]=join.table; if(join.alias)aliasMap[join.alias]=join.table;
    function storeJC(c,rr,v){for(const col of tbl.columns){c[ta+'.'+col]=v===null?null:rr[col];if(!join.alias)c[join.table+'.'+col]=v===null?null:rr[col];if(!(col in c))c[col]=v===null?null:rr[col];}}
    if(join.using){const nr=[];for(const lr of rows){let m=false;for(const rr of tbl.rows){let ok=true;for(const col of join.using){if(!valuesEqual(lr[col],rr[col])){ok=false;break;}}if(ok){const c={...lr};storeJC(c,rr,1);nr.push(c);m=true;}}if(!m&&(join.type==='LEFT'||join.type==='FULL')){const c={...lr};storeJC(c,{},null);nr.push(c);}}rows=nr;}
    else if(join.on){const nr=[];for(const lr of rows){let m=false;for(const rr of tbl.rows){const c={...lr};storeJC(c,rr,1);if(evalExpr(join.on,c)){nr.push(c);m=true;}}if(!m&&(join.type==='LEFT'||join.type==='FULL')){const c={...lr};storeJC(c,{},null);nr.push(c);}}rows=nr;}
    else{const nr=[];for(const lr of rows){for(const rr of tbl.rows){const c={...lr};storeJC(c,rr,1);nr.push(c);}}rows=nr;}
    const jlabel = (join.alias ? join.table.toLowerCase() + ' ' + join.alias.toLowerCase() : join.table.toLowerCase());
    const joinActive = join.using ? new Set(join.using.map(c => c.toUpperCase())) : join.on ? collectColumns(join.on) : new Set();
    const joinClause = Array.isArray(clauses['JOIN']) ? clauses['JOIN'][joinIdx] : clauses['JOIN'];
    joinIdx++;
    // Build join highlight info
    const jColHL = join.on ? buildColHLFromExpr(join.on, 'hl-join-col') : new Map();
    const jLinks = [];
    if (join.using) {
      const prevTables = [...(steps.length > 0 && steps[0].hlInfo ? steps[0].hlInfo.tablesFrom : [])];
      for (const col of join.using) {
        const cu = col.toUpperCase();
        if (prevTables.length > 0) jLinks.push({ leftTable: prevTables[0], leftCol: cu, rightTable: join.table.toUpperCase(), rightCol: cu });
        const k1 = prevTables[0] + '\t' + cu, k2 = join.table.toUpperCase() + '\t' + cu;
        if (!jColHL.has(k1)) jColHL.set(k1, new Set()); jColHL.get(k1).add('hl-join-col');
        if (!jColHL.has(k2)) jColHL.set(k2, new Set()); jColHL.get(k2).add('hl-join-col');
      }
    } else if (join.on) {
      // Extract join links from ON: look for t1.col = t2.col patterns
      (function extractLinks(e) {
        if (!e) return;
        if (e.type === 'binary' && e.op === '=' && e.left.type === 'column' && e.right.type === 'column' && e.left.table && e.right.table) {
          jLinks.push({ leftTable: aliasMap[e.left.table] || e.left.table, leftCol: e.left.name, rightTable: aliasMap[e.right.table] || e.right.table, rightCol: e.right.name });
        }
        if (e.type === 'binary') { extractLinks(e.left); extractLinks(e.right); }
      })(join.on);
    }
    steps.push({ step: 'join', label: joinClause || 'JOIN ' + jlabel, joinType: join.type, before: snapshot(beforeRows), after: snapshot(rows), newCols: tbl.columns, activeCols: joinActive,
      hlInfo: { tablesFrom: new Set(), tablesJoin: new Set([join.table.toUpperCase()]), colHL: jColHL, joinLinks: jLinks } });
  }

  // WHERE
  if (query.where) {
    const beforeRows = rows;
    const passed = [], failed = [];
    for (const r of rows) { if (evalExpr(query.where, r) === true) passed.push(r); else failed.push(r); }
    rows = passed;
    // Show mix: some passed + some failed
    const beforeMix = [];
    const showFail = failed.slice(0, 2);
    const showPass = passed.slice(0, 2);
    for (const r of showPass) beforeMix.push({ row: r, pass: true });
    for (const r of showFail) beforeMix.push({ row: r, pass: false });
    steps.push({ step: 'where', label: clauses['WHERE'] || 'WHERE', before: { columns: displayCols(beforeRows), rows: beforeMix, total: beforeRows.length }, after: snapshot(rows), filter: true, activeCols: collectColumns(query.where),
      hlInfo: { tablesFrom: new Set(), tablesJoin: new Set(), colHL: buildColHLFromExpr(query.where, 'hl-where'), joinLinks: [] } });
  }

  // GROUP BY
  if (query.groupBy.length > 0) {
    const beforeRows = rows;
    const g = new Map();
    for (const r of rows) { const k = query.groupBy.map(e => { const v = evalExpr(e, r); return v === null ? '__NULL__' : String(v); }).join('|||'); if (!g.has(k)) g.set(k, []); g.get(k).push(r); }
    const gr = []; for (const [, grs] of g) gr.push({ __group__: grs, ...grs[0] }); rows = gr;
    const groupActive = new Set(); for (const e of query.groupBy) collectColumns(e).forEach(c => groupActive.add(c));
    const groupColHL = new Map(); for (const e of query.groupBy) { const m = buildColHLFromExpr(e, 'hl-group'); for (const [k, v] of m) { if (!groupColHL.has(k)) groupColHL.set(k, new Set()); v.forEach(c => groupColHL.get(k).add(c)); } }
    steps.push({ step: 'group', label: clauses['GROUP BY'] || 'GROUP BY', before: snapshot(beforeRows), after: { columns: displayCols(rows), rows: rows.slice(0, MAX_PREVIEW), total: rows.length, isGrouped: true, groups: [...g.values()].slice(0, MAX_PREVIEW).map(g => g.length) }, activeCols: groupActive,
      hlInfo: { tablesFrom: new Set(), tablesJoin: new Set(), colHL: groupColHL, joinLinks: [] } });
  } else if (hasAgg(query.columns) || query.having) {
    rows = [{ __group__: rows, ...(rows[0] || {}) }];
  }

  // HAVING
  if (query.having) {
    const beforeRows = rows;
    const passed = [], failed = [];
    for (const r of rows) { if (evalExpr(query.having, r) === true) passed.push(r); else failed.push(r); }
    rows = passed;
    const beforeMix = [];
    for (const r of passed.slice(0, 2)) beforeMix.push({ row: r, pass: true });
    for (const r of failed.slice(0, 2)) beforeMix.push({ row: r, pass: false });
    steps.push({ step: 'having', label: clauses['HAVING'] || 'HAVING', before: { columns: displayCols(beforeRows), rows: beforeMix, total: beforeRows.length }, after: snapshot(rows), filter: true, activeCols: collectColumns(query.having),
      hlInfo: { tablesFrom: new Set(), tablesJoin: new Set(), colHL: buildColHLFromExpr(query.having, 'hl-having'), joinLinks: [] } });
  }

  // CASE WHEN step ‚Äî show evaluation of CASE expressions before SELECT
  const caseExprs = query.columns.filter(c => c.expr && c.expr.type === 'case');
  if (caseExprs.length > 0) {
    const caseDetails = [];
    const previewRows = rows.slice(0, 4);
    for (const col of caseExprs) {
      const ce = col.expr;
      const alias = (col.alias || 'CASE').toUpperCase();
      for (const row of previewRows) {
        const inputCol = collectColumns(ce).values().next().value;
        const inputVal = inputCol ? (row[inputCol] !== undefined ? row[inputCol] : null) : null;
        let matched = false;
        for (let wi = 0; wi < ce.whens.length; wi++) {
          const w = ce.whens[wi];
          let cond;
          if (ce.simple) {
            cond = valuesEqual(evalExpr(ce.simple, row), evalExpr(w.when, row));
          } else {
            cond = evalExpr(w.when, row) === true;
          }
          if (cond && !matched) {
            caseDetails.push({ inputVal, whenIdx: wi, when: w, result: evalExpr(w.then, row), match: true, alias });
            matched = true;
          }
        }
        if (!matched) {
          caseDetails.push({ inputVal, whenIdx: -1, when: null, result: ce.else ? evalExpr(ce.else, row) : null, match: false, alias, isElse: true });
        }
      }
    }
    steps.push({ step: 'case', label: 'CASE WHEN vyhodnocen√≠', before: null, after: null, caseDetails, caseExprs: caseExprs.map(c => c.expr),
      hlInfo: { tablesFrom: new Set(), tablesJoin: new Set(), colHL: new Map(), joinLinks: [] } });
  }

  // SELECT
  const rc = [], rr = [];
  for (const col of query.columns) {
    if (col.type === 'star') { const ts = [...query.from, ...query.joins.map(j => ({ name: j.table, alias: j.alias }))]; for (const t of ts) { if (t.type === 'subquery') { if (rows.length > 0) for (const k of Object.keys(rows[0])) { if (k === '__group__') continue; if (!k.includes('.')) rc.push(k); } } else { const tb = getTable(t.name); for (const c of tb.columns) rc.push(c); } } }
    else { rc.push((col.alias || exprName(col.expr)).toUpperCase()); }
  }
  for (const row of rows) {
    const res = {}; let ci = 0;
    for (const col of query.columns) {
      if (col.type === 'star') { const ts = [...query.from, ...query.joins.map(j => ({ name: j.table, alias: j.alias }))]; for (const t of ts) { if (t.type === 'subquery') { for (const k of Object.keys(row)) { if (k === '__group__') continue; if (!k.includes('.')) { res[k] = row[k]; ci++; } } } else { const tb = getTable(t.name); for (const c of tb.columns) { const al = t.alias || t.name; res[rc[ci]] = row[al + '.' + c] !== undefined ? row[al + '.' + c] : row[c]; ci++; } } } }
      else { res[rc[ci]] = evalExpr(col.expr, row); ci++; }
    }
    rr.push(res);
  }
  const beforeSelect = snapshot(rows);
  let fr = rr;
  if (query.distinct) { const seen = new Set(); fr = []; for (const r of rr) { const k = rc.map(c => r[c] === null ? '__NULL__' : String(r[c])).join('|||'); if (!seen.has(k)) { seen.add(k); fr.push(r); } } }
  const selectActive = new Set(); for (const c of query.columns) { if (c.expr) collectColumns(c.expr).forEach(x => selectActive.add(x)); }
  const selectColHL = new Map(); for (const c of query.columns) { if (c.expr) { const m = buildColHLFromExpr(c.expr, 'hl-select'); for (const [k, v] of m) { if (!selectColHL.has(k)) selectColHL.set(k, new Set()); v.forEach(x => selectColHL.get(k).add(x)); } } }
  steps.push({ step: 'select', label: clauses['SELECT'] || 'SELECT', before: beforeSelect, after: { columns: rc, rows: fr.slice(0, MAX_PREVIEW), total: fr.length }, activeCols: selectActive,
    hlInfo: { tablesFrom: new Set(), tablesJoin: new Set(), colHL: selectColHL, joinLinks: [] } });

  // ORDER BY
  if (query.orderBy.length > 0) {
    const beforeOrder = fr.slice(0, MAX_PREVIEW);
    fr.sort((a, b) => { for (const ob of query.orderBy) { const va = evalExprR(ob.expr, a, rc), vb = evalExprR(ob.expr, b, rc), c = cmpVals(va, vb); if (c !== 0) return ob.dir === 'DESC' ? -c : c; } return 0; });
    const orderActive = new Set(); for (const o of query.orderBy) collectColumns(o.expr).forEach(c => orderActive.add(c));
    const orderColHL = new Map(); for (const o of query.orderBy) { const m = buildColHLFromExpr(o.expr, 'hl-order'); for (const [k, v] of m) { if (!orderColHL.has(k)) orderColHL.set(k, new Set()); v.forEach(x => orderColHL.get(k).add(x)); } }
    steps.push({ step: 'order', label: clauses['ORDER BY'] || 'ORDER BY', before: { columns: rc, rows: beforeOrder, total: fr.length }, after: { columns: rc, rows: fr.slice(0, MAX_PREVIEW), total: fr.length }, activeCols: orderActive,
      hlInfo: { tablesFrom: new Set(), tablesJoin: new Set(), colHL: orderColHL, joinLinks: [] } });
  }

  return steps;
}

function executeASTStepped(sql) {
  let query;
  try { query = parseSQL(sql); } catch(e) { return []; }

  // Handle set operations (UNION / INTERSECT / MINUS)
  if (query.type === 'set_op') {
    return executeASTSteppedSetOp(query, sql);
  }

  return executeASTSteppedQuery(query, sql);
}

function executeASTSteppedSetOp(query, sql) {
  const steps = [];
  const MAX_PREVIEW = 2;

  // Collect all parts of the set operation
  function collectParts(q) {
    if (q.type === 'set_op') {
      const left = collectParts(q.left);
      const right = collectParts(q.right);
      return [...left, { op: q.op, query: right[0].query }];
    }
    return [{ op: null, query: q }];
  }
  const parts = collectParts(query);

  // Split SQL text into sub-query texts
  const sqlParts = [];
  if (sql) {
    const upper = sql.toUpperCase();
    const splits = [];
    let depth = 0;
    for (let i = 0; i < sql.length; i++) {
      if (sql[i] === '(') depth++;
      else if (sql[i] === ')') depth--;
      else if (depth === 0) {
        for (const kw of ['UNION ALL', 'UNION', 'INTERSECT', 'MINUS']) {
          if (upper.substring(i, i + kw.length) === kw && (i === 0 || /\s/.test(sql[i-1])) && (i + kw.length >= sql.length || /\s/.test(sql[i + kw.length]))) {
            splits.push({ pos: i, len: kw.length });
            break;
          }
        }
      }
    }
    if (splits.length === 0) { sqlParts.push(sql); }
    else {
      let prev = 0;
      for (const sp of splits) { sqlParts.push(sql.substring(prev, sp.pos).trim()); prev = sp.pos + sp.len; }
      sqlParts.push(sql.substring(prev).trim());
    }
  }

  // Step through each SELECT sub-query
  const partResults = [];
  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];
    const partSql = i < sqlParts.length ? sqlParts[i] : null;
    const partSteps = executeASTSteppedQuery(part.query, partSql);
    // Add sub-query label prefix
    const prefix = parts.length === 2 ? (i === 0 ? '‚ë† ' : '‚ë° ') : `${String.fromCodePoint(0x2460 + i)} `;
    for (const s of partSteps) {
      s.label = prefix + s.label;
      steps.push(s);
    }
    // Execute to get result
    const result = executeAST(part.query);
    partResults.push(result);

    // Add separator arrow between sub-queries
    if (i < parts.length - 1 && parts[i + 1].op) {
      // The op label step will be added as the merge step
    }
  }

  // Now add the merge step
  if (partResults.length >= 2) {
    let merged = partResults[0];
    let opLabel = '';
    let partIdx = 1;
    // Re-walk the tree to get ops in order
    function getOps(q) {
      if (q.type === 'set_op') { const left = getOps(q.left); return [...left, q.op]; }
      return [];
    }
    const ops = getOps(query);

    for (let i = 0; i < ops.length; i++) {
      const op = ops[i];
      const right = partResults[i + 1];
      const cols = merged.columns;
      const key = r => cols.map(c => { const v = r[c]; return v === null ? '__NULL__' : String(v); }).join('|||');

      let resultRows;
      if (op === 'UNION ALL') {
        resultRows = [...merged.rows, ...right.rows];
      } else if (op === 'UNION') {
        const seen = new Set();
        resultRows = [];
        for (const r of [...merged.rows, ...right.rows]) { const k = key(r); if (!seen.has(k)) { seen.add(k); resultRows.push(r); } }
      } else if (op === 'INTERSECT') {
        const leftKeys = new Set(merged.rows.map(key));
        resultRows = right.rows.filter(r => leftKeys.has(key(r)));
      } else if (op === 'MINUS') {
        const rightKeys = new Set(right.rows.map(key));
        resultRows = merged.rows.filter(r => !rightKeys.has(key(r)));
      }

      const beforeLeft = { columns: cols, rows: merged.rows.slice(0, MAX_PREVIEW), total: merged.rows.length };
      const beforeRight = { columns: right.columns, rows: right.rows.slice(0, MAX_PREVIEW), total: right.rows.length };

      steps.push({
        step: 'setop', label: op,
        before: beforeLeft, after: { columns: cols, rows: resultRows.slice(0, MAX_PREVIEW), total: resultRows.length },
        setopRight: beforeRight,
        hlInfo: { tablesFrom: new Set(), tablesJoin: new Set(), colHL: new Map(), joinLinks: [] }
      });

      merged = { columns: cols, rows: resultRows };
    }
  }

  return steps;
}

// ============================================================
// DATA FLOW RENDERER
// ============================================================
// ============================================================
// TIMELINE
// ============================================================
const timelineSlider = document.getElementById('timelineSlider');
const timelineLabel = document.getElementById('timelineLabel');
const timelineControls = document.getElementById('timelineControls');
const tlPrev = document.getElementById('tlPrev');
const tlPlay = document.getElementById('tlPlay');
const tlNext = document.getElementById('tlNext');
var playInterval = null;

function stopAutoplay() {
  if (playInterval) { clearInterval(playInterval); playInterval = null; }
  tlPlay.textContent = '‚ñ∂'; tlPlay.classList.remove('playing');
}

function startTimelineAutoplay() {
  stopAutoplay();
  timelinePos = 0; timelineSlider.value = 0; renderTimeline(0);
  tlPlay.textContent = '‚è∏'; tlPlay.classList.add('playing');
  playInterval = setInterval(() => {
    if (timelinePos >= timelineSteps.length) { stopAutoplay(); return; }
    timelinePos++;
    timelineSlider.value = timelinePos;
    renderTimeline(timelinePos);
  }, 1200);
}

function hideTimeline() {
  timelineControls.style.display = 'none'; timelineLabel.textContent = '';
}

function updateDataFlow(sql) {
  const container = document.getElementById('dataFlow');
  if (!sql || !/\bFROM\b/i.test(sql)) {
    container.innerHTML = ''; timelineSteps = []; stopAutoplay(); hideTimeline();
    return;
  }

  let steps;
  try { steps = executeASTStepped(sql); } catch(e) { container.innerHTML = ''; timelineSteps = []; stopAutoplay(); hideTimeline(); return; }
  if (steps.length === 0) { container.innerHTML = ''; timelineSteps = []; stopAutoplay(); hideTimeline(); return; }

  timelineSteps = steps;
  timelineSlider.max = steps.length;
  timelineSlider.value = steps.length;
  timelineControls.style.display = '';
  timelinePos = steps.length;
  renderTimeline(timelinePos);
}

function renderTimeline(pos) {
  const container = document.getElementById('dataFlow');
  const steps = timelineSteps;
  if (steps.length === 0) { container.innerHTML = ''; return; }

  // Update label
  if (pos === 0) {
    timelineLabel.textContent = 'Krok 0/' + steps.length;
  } else {
    const s = steps[pos - 1];
    timelineLabel.textContent = 'Krok ' + pos + '/' + steps.length;
  }

  // Render data flow cards up to pos
  let html = '';
  for (let si = 0; si < pos; si++) {
    const s = steps[si];
    if (si > 0) html += '<div class="df-arrow">‚Üì</div>';
    html += `<div class="df-card df-${s.step}">`;
    html += `<div class="df-card-header"><span class="df-step-num">${si + 1}</span><span>${escapeHTML(s.label)}</span>`;
    if (s.step === 'setop' && s.setopRight) html += `<span class="df-count">${s.before.total} + ${s.setopRight.total} ‚Üí ${s.after.total} ≈ô√°dk≈Ø</span>`;
    else if (s.before && s.after) html += `<span class="df-count">${s.before.total || '?'} ‚Üí ${s.after.total} ≈ô√°dk≈Ø</span>`;
    else if (s.after) html += `<span class="df-count">${s.after.total} ≈ô√°dk≈Ø</span>`;
    html += '</div>';

    const ac = s.activeCols || new Set();
    const afterAc = (s.step === 'select') ? new Set() : ac;

    if (s.step === 'case' && s.caseDetails) {
      html += '<div class="df-card-body df-single">';
      html += renderCaseTable(s.caseDetails, s.caseExprs);
      html += '</div>';
    } else if (s.step === 'setop' && s.setopRight) {
      html += '<div class="df-card-body">';
      html += '<div class="df-half"><div class="df-half-label">Lev√° ƒç√°st (' + s.before.total + ')</div>';
      html += renderMiniTable(s.before.columns, s.before.rows, s.before.total);
      html += '</div>';
      html += '<div class="df-half"><div class="df-half-label">Prav√° ƒç√°st (' + s.setopRight.total + ')</div>';
      html += renderMiniTable(s.setopRight.columns, s.setopRight.rows, s.setopRight.total);
      html += '</div></div>';
      html += '<div class="df-card-body df-single"><div class="df-half-label">V√Ωsledek (' + s.after.total + ')</div>';
      html += renderMiniTable(s.after.columns, s.after.rows, s.after.total);
      html += '</div>';
    } else if (s.filter && s.before && s.after) {
      html += '<div class="df-card-body">';
      html += '<div class="df-half"><div class="df-half-label">Vstup (' + (s.before.total) + ')</div>';
      html += renderMixTable(s.before.columns, s.before.rows, ac);
      html += '</div>';
      html += '<div class="df-half"><div class="df-half-label">V√Ωstup (' + s.after.total + ')</div>';
      html += renderMiniTable(s.after.columns, s.after.rows, s.after.total, null, afterAc);
      html += '</div></div>';
    } else if (s.before && s.after) {
      // For JOIN steps, add Venn diagram
      if (s.step === 'join') {
        html += '<div class="df-card-body">';
        html += '<div class="df-half"><div class="df-half-label">P≈ôed (' + s.before.total + ')</div>';
        html += renderMiniTable(s.before.columns, s.before.rows, s.before.total, null, ac);
        html += '</div>';
        html += '<div class="df-half"><div class="df-half-label">Po (' + s.after.total + ')</div>';
        html += renderMiniTable(s.after.columns, s.after.rows, s.after.total, s.newCols, afterAc);
        html += '</div></div>';
        html += renderJoinVenn(s.joinType || 'INNER');
      } else {
        html += '<div class="df-card-body">';
        html += '<div class="df-half"><div class="df-half-label">P≈ôed (' + s.before.total + ')</div>';
        html += renderMiniTable(s.before.columns, s.before.rows, s.before.total, null, ac);
        html += '</div>';
        html += '<div class="df-half"><div class="df-half-label">Po (' + s.after.total + ')</div>';
        html += renderMiniTable(s.after.columns, s.after.rows, s.after.total, s.newCols, afterAc);
        html += '</div></div>';
      }
    } else if (s.after) {
      html += '<div class="df-card-body df-single">';
      html += renderMiniTable(s.after.columns, s.after.rows, s.after.total, null, afterAc);
      html += '</div>';
    }
    html += '</div>';
  }
  container.innerHTML = html;

  // Update pipeline highlighting for current timeline position
  updatePipelineForStep(pos);

  // Update flow bar for current timeline position
  updateFlowForStep(pos);
}

function updatePipelineForStep(pos) {
  const steps = timelineSteps;
  // Reset all highlights
  document.querySelectorAll('.p-table').forEach(el => el.classList.remove('hl-from', 'hl-join'));
  document.querySelectorAll('.p-col').forEach(el => el.classList.remove('hl-select', 'hl-where', 'hl-join-col', 'hl-group', 'hl-having', 'hl-order'));

  // Accumulate highlights from steps 0..pos-1
  const allTablesFrom = new Set(), allTablesJoin = new Set();
  const allColHL = new Map();
  const allJoinLinks = [];

  for (let i = 0; i < pos && i < steps.length; i++) {
    const hl = steps[i].hlInfo;
    if (!hl) continue;
    hl.tablesFrom.forEach(t => allTablesFrom.add(t));
    hl.tablesJoin.forEach(t => allTablesJoin.add(t));
    for (const [key, classes] of hl.colHL) {
      if (!allColHL.has(key)) allColHL.set(key, new Set());
      classes.forEach(c => allColHL.get(key).add(c));
    }
    for (const link of hl.joinLinks) allJoinLinks.push(link);
  }

  // Apply table highlights
  document.querySelectorAll('.p-table').forEach(el => {
    const n = el.dataset.table;
    if (allTablesFrom.has(n)) el.classList.add('hl-from');
    if (allTablesJoin.has(n)) el.classList.add('hl-join');
  });

  // Apply column highlights
  document.querySelectorAll('.p-col').forEach(el => {
    const col = el.dataset.col;
    const table = el.closest('.p-table')?.dataset.table;
    if (!table) return;
    const key = table + '\t' + col;
    const classes = allColHL.get(key);
    if (classes) classes.forEach(c => el.classList.add(c));
  });

  // Draw join lines
  drawJoinLines(allJoinLinks);
}

function updateFlowForStep(pos) {
  const steps = timelineSteps;
  const bar = document.getElementById('flowBar');
  bar.innerHTML = '<span class="flow-label">Po≈ôad√≠ vykon√°n√≠:</span>';
  // Collect unique step types up to pos
  const activeIds = [];
  for (let i = 0; i < pos && i < steps.length; i++) {
    const id = steps[i].step;
    if (!activeIds.includes(id)) activeIds.push(id);
  }
  let first = true;
  for (const step of FLOW_STEPS) {
    if (!activeIds.includes(step.id)) continue;
    if (!first) { const arrow = document.createElement('span'); arrow.className = 'flow-arrow'; arrow.textContent = '‚Üí'; bar.appendChild(arrow); }
    first = false;
    const el = document.createElement('span');
    el.className = `flow-step ${step.cls} active`;
    el.textContent = step.label;
    el.onclick = (e) => { e.stopPropagation(); el.classList.toggle('show-tip'); };
    const tip = document.createElement('div');
    tip.className = 'flow-tooltip';
    tip.textContent = step.desc;
    el.appendChild(tip);
    bar.appendChild(el);
  }
}

// Slider event
timelineSlider.addEventListener('input', () => {
  stopAutoplay();
  timelinePos = parseInt(timelineSlider.value);
  renderTimeline(timelinePos);
});

// Prev / Next / Play buttons
tlPrev.addEventListener('click', () => {
  stopAutoplay();
  if (timelinePos > 0) { timelinePos--; timelineSlider.value = timelinePos; renderTimeline(timelinePos); }
});
tlNext.addEventListener('click', () => {
  stopAutoplay();
  if (timelinePos < timelineSteps.length) { timelinePos++; timelineSlider.value = timelinePos; renderTimeline(timelinePos); }
});
tlPlay.addEventListener('click', () => {
  if (playInterval) { stopAutoplay(); return; }
  if (timelinePos >= timelineSteps.length) { timelinePos = 0; timelineSlider.value = 0; renderTimeline(0); }
  tlPlay.textContent = '‚è∏'; tlPlay.classList.add('playing');
  playInterval = setInterval(() => {
    if (timelinePos >= timelineSteps.length) { stopAutoplay(); return; }
    timelinePos++;
    timelineSlider.value = timelinePos;
    renderTimeline(timelinePos);
  }, 1200);
});

// Scroll wheel on timeline controls = timeline step
document.getElementById('timelineControls').addEventListener('wheel', (e) => {
  if (timelineSteps.length === 0) return;
  e.preventDefault();
  stopAutoplay();
  if (e.deltaY > 0 && timelinePos < timelineSteps.length) timelinePos++;
  else if (e.deltaY < 0 && timelinePos > 0) timelinePos--;
  timelineSlider.value = timelinePos;
  renderTimeline(timelinePos);
}, { passive: false });

function filterCols(columns, activeCols, newCols) {
  if (!activeCols || activeCols.size === 0) return columns;
  const keep = new Set(activeCols);
  if (newCols) for (const c of newCols) keep.add(c);
  return columns.filter(c => keep.has(c));
}

function renderMiniTable(columns, rows, total, newCols, activeCols) {
  const cols = filterCols(columns, activeCols, newCols);
  if (!cols || cols.length === 0) return '';
  const nc = new Set(newCols || []);
  let h = '<table class="df-mini-table"><thead><tr>';
  for (const c of cols) h += `<th${nc.has(c) ? ' class="df-new-col"' : ''}>${escapeHTML(c)}</th>`;
  h += '</tr></thead><tbody>';
  for (const r of rows) {
    h += '<tr>';
    for (const c of cols) { const v = r[c]; h += v === null || v === undefined ? '<td class="df-null">NULL</td>' : `<td>${escapeHTML(String(v))}</td>`; }
    h += '</tr>';
  }
  if (total > rows.length) h += `<tr><td colspan="${cols.length}" class="df-more">‚Ä¶ a dal≈°√≠ch ${total - rows.length}</td></tr>`;
  h += '</tbody></table>';
  return h;
}

function renderCaseTable(details, caseExprs) {
  if (!details || details.length === 0) return '';
  let h = '<table class="df-case-table"><thead><tr>';
  h += '<th>Hodnota</th><th>Splnƒõn√° podm√≠nka</th><th>‚Üí V√Ωsledek</th>';
  h += '</tr></thead><tbody>';
  for (const d of details) {
    const cls = d.match ? 'df-case-match' : 'df-case-match';
    const inputStr = d.inputVal === null ? 'NULL' : String(d.inputVal);
    let condStr;
    if (d.isElse) {
      condStr = 'ELSE (≈æ√°dn√Ω WHEN nesplnƒõn)';
    } else if (d.when && d.when.when) {
      condStr = 'WHEN ' + describeExpr(d.when.when);
    } else {
      condStr = 'WHEN #' + (d.whenIdx + 1);
    }
    const resStr = d.result === null ? 'NULL' : String(d.result);
    h += `<tr class="${cls}">`;
    h += `<td>${escapeHTML(inputStr)}</td>`;
    h += `<td>${escapeHTML(condStr)}</td>`;
    h += `<td class="df-case-result">${escapeHTML(resStr)}</td>`;
    h += '</tr>';
  }
  h += '</tbody></table>';
  return h;
}

function describeExpr(expr) {
  if (!expr) return '?';
  if (expr.type === 'literal') return expr.value === null ? 'NULL' : String(expr.value);
  if (expr.type === 'column') return (expr.table ? expr.table + '.' : '') + expr.name;
  if (expr.type === 'binary') {
    const l = describeExpr(expr.left), r = describeExpr(expr.right);
    return l + ' ' + expr.op + ' ' + r;
  }
  if (expr.type === 'is_null') return describeExpr(expr.expr) + (expr.not ? ' IS NOT NULL' : ' IS NULL');
  if (expr.type === 'between') return describeExpr(expr.expr) + ' BETWEEN ' + describeExpr(expr.low) + ' AND ' + describeExpr(expr.high);
  if (expr.type === 'like') return describeExpr(expr.expr) + (expr.not ? ' NOT LIKE ' : ' LIKE ') + "'" + expr.pattern + "'";
  if (expr.type === 'agg') return expr.fn + '(' + (expr.arg ? describeExpr(expr.arg) : '*') + ')';
  if (expr.type === 'func') return expr.fn + '(' + expr.args.map(describeExpr).join(', ') + ')';
  return '‚Ä¶';
}

function renderMixTable(columns, mixRows, activeCols) {
  const cols = filterCols(columns, activeCols);
  if (!cols || cols.length === 0) return '';
  let h = '<table class="df-mini-table"><thead><tr>';
  for (const c of cols) h += `<th>${escapeHTML(c)}</th>`;
  h += '<th></th></tr></thead><tbody>';
  for (const m of mixRows) {
    const r = m.row;
    h += `<tr class="${m.pass ? 'df-pass' : 'df-fail'}">`;
    for (const c of cols) { const v = r[c]; h += v === null || v === undefined ? '<td class="df-null">NULL</td>' : `<td>${escapeHTML(String(v))}</td>`; }
    h += `<td>${m.pass ? '‚úì' : '‚úó'}</td></tr>`;
  }
  h += '</tbody></table>';
  return h;
}

// ============================================================
// JOIN VENN DIAGRAM
// ============================================================
function renderJoinVenn(joinType) {
  const configs = {
    'INNER': {
      leftFill: 'rgba(188,140,255,0.15)', rightFill: 'rgba(188,140,255,0.15)', centerFill: 'rgba(188,140,255,0.55)',
      desc: 'Pouze shody z obou tabulek', label: 'INNER JOIN'
    },
    'LEFT': {
      leftFill: 'rgba(188,140,255,0.55)', rightFill: 'rgba(188,140,255,0.15)', centerFill: 'rgba(188,140,255,0.55)',
      desc: 'V≈°e z lev√© + shody z prav√© (NULL kde nen√≠ shoda)', label: 'LEFT JOIN'
    },
    'RIGHT': {
      leftFill: 'rgba(188,140,255,0.15)', rightFill: 'rgba(188,140,255,0.55)', centerFill: 'rgba(188,140,255,0.55)',
      desc: 'V≈°e z prav√© + shody z lev√© (NULL kde nen√≠ shoda)', label: 'RIGHT JOIN'
    },
    'FULL': {
      leftFill: 'rgba(188,140,255,0.55)', rightFill: 'rgba(188,140,255,0.55)', centerFill: 'rgba(188,140,255,0.55)',
      desc: 'V≈°e z obou tabulek (NULL kde nen√≠ shoda)', label: 'FULL OUTER JOIN'
    },
    'CROSS': {
      leftFill: 'rgba(188,140,255,0.35)', rightFill: 'rgba(188,140,255,0.35)', centerFill: 'rgba(188,140,255,0.35)',
      desc: 'Kart√©zsk√Ω souƒçin ‚Äî ka≈æd√Ω ≈ô√°dek s ka≈æd√Ωm', label: 'CROSS JOIN'
    },
    'NATURAL': {
      leftFill: 'rgba(188,140,255,0.25)', rightFill: 'rgba(188,140,255,0.25)', centerFill: 'rgba(188,140,255,0.65)',
      desc: 'Auto-join podle shodn√Ωch n√°zv≈Ø sloupc≈Ø', label: 'NATURAL JOIN'
    }
  };
  const cfg = configs[joinType] || configs['INNER'];
  // SVG Venn: two overlapping circles
  const r = 26, cx1 = 38, cx2 = 78, cy = 35, w = 116, h = 70;
  const stroke = 'rgba(188,140,255,0.7)';
  let svg = `<svg class="df-join-venn-svg" viewBox="0 0 ${w} ${h}" xmlns="http://www.w3.org/2000/svg">`;
  // Left circle
  svg += `<circle cx="${cx1}" cy="${cy}" r="${r}" fill="${cfg.leftFill}" stroke="${stroke}" stroke-width="1.5"/>`;
  // Right circle
  svg += `<circle cx="${cx2}" cy="${cy}" r="${r}" fill="${cfg.rightFill}" stroke="${stroke}" stroke-width="1.5"/>`;
  // Center overlap highlight (clip path approach via a simple overlay circle if needed)
  // Labels
  svg += `<text x="${cx1-8}" y="${cy+4}" font-size="9" fill="rgba(188,140,255,0.9)" font-family="JetBrains Mono" font-weight="700" text-anchor="middle">A</text>`;
  svg += `<text x="${cx2+8}" y="${cy+4}" font-size="9" fill="rgba(188,140,255,0.9)" font-family="JetBrains Mono" font-weight="700" text-anchor="middle">B</text>`;
  svg += '</svg>';

  return `<div class="df-join-venn">${svg}<span class="df-join-type-badge">${cfg.label}</span><div class="df-join-desc">${cfg.desc}</div></div>`;
}

// ============================================================
// TASKS PANEL
// ============================================================
var tasksData = [];       // [{id, chapterNum, chapterTitle, num, text, solutionRows, solutionCols, solved, autoChecked}]
var tasksActiveId = null;
var tasksDocked = false;
var tasksRecordMode = false; // when true, next query execution records solution for active task

function tasksOverlayClick() {
  if (!tasksDocked) toggleTasksPanel();
}

function toggleTasksPanel() {
  const panel = document.getElementById('tasksPanel');
  const overlay = document.getElementById('tasksOverlay');
  const btn = document.getElementById('btnTasks');
  const isOpen = panel.classList.contains('open');
  if (isOpen && !tasksDocked) {
    panel.classList.remove('open');
    overlay.classList.remove('show');
    btn.classList.remove('active');
  } else if (!isOpen) {
    panel.classList.add('open');
    if (!tasksDocked) overlay.classList.add('show');
    btn.classList.add('active');
  }
}

function toggleTasksDocked() {
  tasksDocked = !tasksDocked;
  const pinBtn = document.getElementById('tasksPinBtn');
  pinBtn.classList.toggle('pinned', tasksDocked);
  pinBtn.title = tasksDocked ? 'Zru≈°it p≈ôichycen√≠ (panel p≈ôekryje str√°nku)' : 'P≈ôichytit panel vedle editoru (z√∫≈æ√≠ str√°nku)';
  const panel = document.getElementById('tasksPanel');
  const appBody = document.getElementById('appBody');
  const app = document.querySelector('.app');

  if (tasksDocked) {
    // Move panel inside app-body so it pushes main-content
    app.classList.add('tasks-docked');
    appBody.appendChild(panel);
    document.getElementById('tasksOverlay').classList.remove('show');
    // Make sure panel is open
    if (!panel.classList.contains('open')) {
      panel.classList.add('open');
      document.getElementById('btnTasks').classList.add('active');
    }
  } else {
    // Move panel back to body as floating overlay
    app.classList.remove('tasks-docked');
    document.body.appendChild(panel);
    if (panel.classList.contains('open')) {
      document.getElementById('tasksOverlay').classList.add('show');
    }
  }
  setTimeout(() => { updateEditor(); if (window.__lastLinks) drawJoinLines(window.__lastLinks); }, 80);
}

function handleTasksFile(event) {
  const file = event.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (e) => { parseAndLoadTasks(e.target.result); };
  reader.readAsText(file, 'UTF-8');
  event.target.value = '';
}

function showTasksPasteModal() {
  document.getElementById('pasteModalOverlay').style.display = 'flex';
  setTimeout(() => document.getElementById('pasteModalText').focus(), 50);
}

function hideTasksPasteModal() {
  document.getElementById('pasteModalOverlay').style.display = 'none';
}

function loadTasksFromPaste() {
  const text = document.getElementById('pasteModalText').value.trim();
  if (!text) return;
  parseAndLoadTasks(text);
  hideTasksPasteModal();
}

function parseAndLoadTasks(text) {
  const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 0);
  const tasks = [];
  let currentChapter = null;
  let currentChapterNum = '';
  let taskId = 0;
  for (const line of lines) {
    const chapterMatch = line.match(/^(\d+\.\d+)[\s\t]+(.+)$/);
    if (chapterMatch) {
      currentChapterNum = chapterMatch[1];
      currentChapter = chapterMatch[2].trim();
      continue;
    }
    if (line.match(/^(\d+)[.\t]\s*(.+)$/) && !line.match(/^\d+\.\d+/)) {
      const m = line.match(/^(\d+)[.\t]\s*(.+)$/);
      const num = parseInt(m[1]);
      const taskText = m[2].trim();
      if (taskText.length < 3) continue;
      tasks.push({
        id: ++taskId,
        chapterNum: currentChapterNum || '',
        chapterTitle: currentChapter || '√ökoly',
        num,
        text: taskText,
        solutionRows: null,   // stored as normalized array of row-strings for comparison
        solutionCols: null,
        solved: false,
        autoChecked: false
      });
    }
  }
  if (tasks.length === 0) { alert('Nepoda≈ôilo se naƒç√≠st ≈æ√°dn√© √∫koly. Zkontroluj form√°t textu.'); return; }
  // Assign preset solutions where available
  for (const task of tasks) {
    if (PRESET_SOLUTIONS[task.num]) {
      task.presetRows = PRESET_SOLUTIONS[task.num].rows;
      task.presetCols = PRESET_SOLUTIONS[task.num].cols;
    }
  }
  tasksData = tasks;
  tasksActiveId = null;
  tasksRecordMode = false;
  renderTasksPanel();
  if (!document.getElementById('tasksPanel').classList.contains('open')) toggleTasksPanel();
}

// Normalize a result for comparison (order-independent, case-insensitive strings)
function normalizeResultForStorage(result) {
  if (!result || result.rows.length === 0) return { cols: result.columns, rows: [] };
  const norm = result.rows.map(r =>
    result.columns.map(c => { const v = r[c]; return (v === null || v === undefined) ? '' : String(v).toUpperCase().trim(); }).join('|||')
  ).sort();
  return { cols: result.columns, rows: norm };
}

// Normalize raw data array (for preset solutions)
function normalizeDataForStorage(dataRows) {
  return dataRows.map(row =>
    row.map(v => (v === null || v === undefined) ? '' : String(v).toUpperCase().trim()).join('|||')
  ).sort();
}

function resultsMatchStored(task, userResult) {
  // Support precomputed data rows (preset solutions)
  if (task.presetRows) {
    const norm = normalizeResultForStorage(userResult);
    if (norm.rows.length !== task.presetRows.length) return false;
    if (userResult.columns.length !== task.presetCols) return false;
    for (let i = 0; i < norm.rows.length; i++) {
      if (norm.rows[i] !== task.presetRows[i]) return false;
    }
    return true;
  }
  // Original: recorded solution rows
  if (!task.solutionRows) return false;
  const norm = normalizeResultForStorage(userResult);
  if (norm.rows.length !== task.solutionRows.length) return false;
  if (norm.cols.length !== task.solutionCols.length) return false;
  for (let i = 0; i < norm.rows.length; i++) {
    if (norm.rows[i] !== task.solutionRows[i]) return false;
  }
  return true;
}

// ============================================================
// PRESET SOLUTIONS ‚Äî p≈ôedpoƒç√≠tan√© v√Ωsledky pro FIS cviƒçen√≠
// Form√°t: ƒç√≠slo p≈ô√≠kladu ‚Üí pole ≈ô√°dk≈Ø (ka≈æd√Ω ≈ô√°dek = pole hodnot)
// P≈ôid√°no: p≈ô√≠klady 2‚Äì21 ze zad√°n√≠ 4IT218
// ============================================================
const PRESET_SOLUTIONS = {
  2: { cols: 2, rows: normalizeDataForStorage([
    ['KONADRA','POSLICEK'],['SYKORA','BESTBOY'],['STRNAD','SVACINAR'],
    ['KOS','PROJEKTANT'],['KOS','PROJEKTANT'],['VOREL','BOSS'],['DATEL','BOSS'],
    ['MALY','POSLICEK'],['DLOUHY','KNIHOVNIK'],['VYSOKY','KNIHOVNIK'],
    ['TLUSTY','KNIHOVNIK'],['TLUSTY','SVACINAR'],['OTYLY','BOSS'],['OBROVSKY','BOSS'],
    ['CERNY','PROGRAMATOR'],['CERVENY','PROGRAMATOR'],['ZELENY','PROGRAMATOR'],
    ['ZELENY','PROGRAMATOR'],['FIALKA','PROGRAMATOR'],['FIALOVA','PROGRAMATOR'],
    ['ZLATUSKA','BOSS'],['SEBESTOVA','BOSS'],['MACHOVA','BUFETACKA'],
    ['HORACKOVA','UKLIZECKA'],['HORACKOVA','BUFETACKA'],['PAZOUTOVA','MYCKA NADOBI'],
    ['KADRNOZKOVA','MYCKA NADOBI'],['JONATANOVA','UKLIZECKA'],['CECH','BOSS'],
    ['SLOVAK','SKLADNIK'],['NEMEC','SKLADNIK'],['CECH','SKLADNIK'],
    ['KOCOUR','BOSS'],['KOCOUR','SEF TECHNIK'],['KOBYLKA','TECHNIK'],
    ['KOCICKA','TECHNIK'],['PAPOUSEK','TECHNIK'],['SEFICEK','REDITEL']
  ])},
  3: { cols: 1, rows: normalizeDataForStorage([['ING'],['RNDR'],['DOC']]) },
  4: { cols: 3, rows: normalizeDataForStorage([
    ['KONADRA','5400','6480'],['SYKORA','6000','7200'],['STRNAD','7500','9000'],
    ['KOS','10500','12600'],['KOS','10800','12960'],['VOREL','12000','14400'],
    ['DATEL','12600','15120'],['MALY','6000','7200'],['DLOUHY','9000','10800'],
    ['VYSOKY','10500','12600'],['TLUSTY','11100','13320'],['TLUSTY','6000','7200'],
    ['OTYLY','12000','14400'],['OBROVSKY','13500','16200'],['CERNY','7500','9000'],
    ['CERVENY','9000','10800'],['ZELENY','10500','12600'],['ZELENY','10500','12600'],
    ['FIALKA','10500','12600'],['FIALOVA','10200','12240'],['ZLATUSKA','13500','16200'],
    ['SEBESTOVA','8400','10080'],['MACHOVA','7500','9000'],['HORACKOVA','7500','9000'],
    ['HORACKOVA','7800','9360'],['PAZOUTOVA','6600','7920'],['KADRNOZKOVA','6600','7920'],
    ['JONATANOVA','6600','7920'],['CECH','9000','10800'],['SLOVAK','6600','7920'],
    ['NEMEC','7200','8640'],['CECH','7500','9000'],['KOCOUR','12900','15480'],
    ['KOCOUR','11400','13680'],['KOBYLKA','10500','12600'],['KOCICKA','10200','12240'],
    ['PAPOUSEK','10200','12240'],['SEFICEK','15000','18000']
  ])},
  5: { cols: 1, rows: normalizeDataForStorage([
    ['Pan  KONADRA pracuje v oddeleni c. 1'],
    ['Pan  SYKORA pracuje v oddeleni c. 1'],
    ['Pan  STRNAD pracuje v oddeleni c. 1'],
    ['Pan ING KOS pracuje v oddeleni c. 1'],
    ['Pan ING KOS pracuje v oddeleni c. 1'],
    ['Pan ING VOREL pracuje v oddeleni c. 1'],
    ['Pan RNDR DATEL pracuje v oddeleni c. 1'],
    ['Pan  MALY pracuje v oddeleni c. 2'],
    ['Pan  DLOUHY pracuje v oddeleni c. 2'],
    ['Pan  VYSOKY pracuje v oddeleni c. 2'],
    ['Pan ING TLUSTY pracuje v oddeleni c. 2'],
    ['Pan  TLUSTY pracuje v oddeleni c. 2'],
    ['Pan ING OTYLY pracuje v oddeleni c. 2'],
    ['Pan RNDR OBROVSKY pracuje v oddeleni c. 2'],
    ['Pan  CERNY pracuje v oddeleni c. 3'],
    ['Pan  CERVENY pracuje v oddeleni c. 3'],
    ['Pan ING ZELENY pracuje v oddeleni c. 3'],
    ['Pan ING ZELENY pracuje v oddeleni c. 3'],
    ['Pan ING FIALKA pracuje v oddeleni c. 3'],
    ['Pan RNDR FIALOVA pracuje v oddeleni c. 3'],
    ['Pan RNDR ZLATUSKA pracuje v oddeleni c. 3'],
    ['Pan  SEBESTOVA pracuje v oddeleni c. 4'],
    ['Pan  MACHOVA pracuje v oddeleni c. 4'],
    ['Pan  HORACKOVA pracuje v oddeleni c. 4'],
    ['Pan  HORACKOVA pracuje v oddeleni c. 4'],
    ['Pan  PAZOUTOVA pracuje v oddeleni c. 4'],
    ['Pan  KADRNOZKOVA pracuje v oddeleni c. 4'],
    ['Pan  JONATANOVA pracuje v oddeleni c. 4'],
    ['Pan ING CECH pracuje v oddeleni c. 6'],
    ['Pan  SLOVAK pracuje v oddeleni c. 6'],
    ['Pan  NEMEC pracuje v oddeleni c. 6'],
    ['Pan  CECH pracuje v oddeleni c. 6'],
    ['Pan DOC KOCOUR pracuje v oddeleni c. 8'],
    ['Pan ING KOCOUR pracuje v oddeleni c. 8'],
    ['Pan ING KOBYLKA pracuje v oddeleni c. 8'],
    ['Pan  KOCICKA pracuje v oddeleni c. 8'],
    ['Pan  PAPOUSEK pracuje v oddeleni c. 8'],
    ['Pan DOC SEFICEK pracuje v oddeleni c. 10']
  ])}
};

// Called after every successful query execution
function autoCheckTasksWithResult(userResult) {
  if (tasksData.length === 0) return;

  // Record mode: save result as solution for active task
  if (tasksRecordMode && tasksActiveId !== null) {
    const task = tasksData.find(t => t.id === tasksActiveId);
    if (task) {
      const norm = normalizeResultForStorage(userResult);
      task.solutionRows = norm.rows;
      task.solutionCols = norm.cols;
      tasksRecordMode = false;
      renderTasksPanel();
      // Flash the record button to confirm
      const recBtn = document.getElementById('tasksRecordBtn');
      if (recBtn) {
        recBtn.textContent = '‚úì Ulo≈æeno';
        recBtn.style.background = 'rgba(63,185,80,0.25)';
        recBtn.style.borderColor = 'var(--green)';
        recBtn.style.color = 'var(--green)';
        setTimeout(() => {
          recBtn.textContent = '‚ö° Zaznamenat v√Ωsledek';
          recBtn.style.background = '';
          recBtn.style.borderColor = '';
          recBtn.style.color = '';
        }, 2000);
      }
    }
    return;
  }

  // Auto-check mode: compare against stored solutions
  let anyChanged = false;
  let lastSolvedId = null;
  for (const task of tasksData) {
    if (!task.solutionRows && !task.presetRows) continue;
    if (task.solved) continue;
    if (resultsMatchStored(task, userResult)) {
      task.solved = true;
      task.autoChecked = true;
      anyChanged = true;
      lastSolvedId = task.id;
    }
  }
  if (anyChanged) {
    tasksActiveId = lastSolvedId;
    renderTasksPanel();
    setTimeout(() => {
      const el = document.querySelector(`.tasks-task[data-taskid="${lastSolvedId}"]`);
      if (el) {
        el.style.transition = 'background 0.5s';
        el.style.background = 'rgba(63,185,80,0.3)';
        setTimeout(() => { if (el) el.style.background = ''; }, 1000);
        el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
    }, 60);
  }
}

function startRecordMode() {
  if (tasksActiveId === null) {
    alert('Nejprve vyber √∫kol kliknut√≠m na nƒõj v panelu.');
    return;
  }
  tasksRecordMode = true;
  const recBtn = document.getElementById('tasksRecordBtn');
  if (recBtn) {
    recBtn.textContent = '‚è∫ ƒåek√° na dotaz‚Ä¶';
    recBtn.style.background = 'rgba(210,153,34,0.2)';
    recBtn.style.borderColor = 'var(--yellow)';
    recBtn.style.color = 'var(--yellow)';
  }
}

function renderTasksPanel() {
  const body = document.getElementById('tasksBody');
  const footer = document.getElementById('tasksFooter');
  if (tasksData.length === 0) {
    body.innerHTML = '<div class="tasks-empty-state"><div style="font-size:32px;margin-bottom:12px">üìÑ</div><div style="font-weight:600;margin-bottom:6px;color:var(--text2)">≈Ω√°dn√° cviƒçen√≠</div><div style="font-size:11px;color:var(--text3);line-height:1.6">Nahraj textov√Ω soubor nebo vlo≈æ text se cviƒçen√≠mi.<br>Form√°t: ƒç√≠slo + teƒçka + text √∫kolu.</div></div>';
    footer.style.display = 'none';
    return;
  }

  // Group by chapter
  const chapters = [];
  const chapterMap = new Map();
  for (const task of tasksData) {
    const key = task.chapterNum + '|' + task.chapterTitle;
    if (!chapterMap.has(key)) {
      chapterMap.set(key, { key, num: task.chapterNum, title: task.chapterTitle, tasks: [] });
      chapters.push(chapterMap.get(key));
    }
    chapterMap.get(key).tasks.push(task);
  }

  // Active task info for record bar
  const activeTask = tasksData.find(t => t.id === tasksActiveId);
  const hasSolution = activeTask && activeTask.solutionRows !== null;

  let html = '';

  // Record mode bar (shows when a task is selected)
  if (activeTask) {
    html += `<div class="tasks-record-bar" id="tasksRecordBar">`;
    html += `<span class="tasks-record-task-label">Vybran√Ω: <b>${activeTask.num}.</b> ${escapeHTML(activeTask.text.substring(0, 50))}${activeTask.text.length > 50 ? '‚Ä¶' : ''}</span>`;
    html += `<div style="display:flex;gap:6px;margin-top:5px">`;
    if (hasSolution) {
      html += `<span class="tasks-solution-badge">‚ö° M√° vzorov√Ω v√Ωsledek</span>`;
    }
    html += `<button class="tasks-record-btn" id="tasksRecordBtn" onclick="startRecordMode()">‚ö° Zaznamenat v√Ωsledek</button>`;
    if (hasSolution) {
      html += `<button class="tasks-record-btn tasks-clear-btn" onclick="clearTaskSolution(${activeTask.id})">‚úï Smazat vzor</button>`;
    }
    html += `</div></div>`;
  }

  // Chapter list
  for (const ch of chapters) {
    const solvedCount = ch.tasks.filter(t => t.solved).length;
    html += '<div class="tasks-chapter">';
    html += `<div class="tasks-chapter-header" onclick="toggleTasksChapter(this)">
      <span class="tasks-chapter-toggle">‚ñæ</span>
      <span>${ch.num ? escapeHTML(ch.num) + ' ‚Äî ' : ''}${escapeHTML(ch.title)}</span>
      <span class="tasks-chapter-count">${solvedCount}/${ch.tasks.length}</span>
    </div>`;
    html += '<div class="tasks-task-list">';
    for (const task of ch.tasks) {
      const isActive = task.id === tasksActiveId;
      const isSolved = task.solved;
      const hasRef = task.solutionRows !== null || task.presetRows !== null;
      html += `<div class="tasks-task${isActive ? ' active' : ''}${isSolved ? ' solved' : ''}" data-taskid="${task.id}" onclick="selectTask(${task.id})">`;
      html += `<span class="tasks-task-num">${task.num}.</span>`;
      html += `<span class="tasks-task-text">${escapeHTML(task.text)}${hasRef ? ' <span style="color:var(--yellow);font-size:9px" title="M√° vzorov√Ω v√Ωsledek ‚Äî auto-check aktivn√≠">‚ö°</span>' : ''}</span>`;
      html += `<span class="tasks-task-check" onclick="event.stopPropagation();toggleTaskSolved(${task.id})">${isSolved ? '‚úì' : ''}</span>`;
      html += '</div>';
    }
    html += '</div></div>';
  }

  body.innerHTML = html;

  // Footer progress
  const solved = tasksData.filter(t => t.solved).length;
  const total = tasksData.length;
  document.getElementById('tasksProgressLabel').textContent = `${solved} / ${total} splnƒõno`;
  document.getElementById('tasksProgressFill').style.width = (total > 0 ? solved / total * 100 : 0) + '%';
  footer.style.display = '';
}

function toggleTasksChapter(headerEl) {
  headerEl.closest('.tasks-chapter').classList.toggle('collapsed');
}

function selectTask(id) {
  tasksActiveId = id;
  tasksRecordMode = false; // cancel record mode on task switch
  renderTasksPanel();
  // Scroll selected into view
  setTimeout(() => {
    const el = document.querySelector(`.tasks-task[data-taskid="${id}"]`);
    if (el) el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }, 30);
}

function toggleTaskSolved(id) {
  const task = tasksData.find(t => t.id === id);
  if (!task) return;
  task.solved = !task.solved;
  if (!task.solved) task.autoChecked = false;
  renderTasksPanel();
}

function clearTaskSolution(id) {
  const task = tasksData.find(t => t.id === id);
  if (!task) return;
  task.solutionRows = null;
  task.solutionCols = null;
  task.solved = false;
  task.autoChecked = false;
  renderTasksPanel();
}

// ============================================================
// INIT
// ============================================================
initPipeline();
initExamples();
initDict();

// Detect macOS and update shortcut labels
const isMac = /Mac|iPod|iPhone|iPad/.test(navigator.platform);
const shortcutLabel = isMac ? '‚åò‚Üµ' : 'Ctrl+‚Üµ';
const shortcutText = isMac ? '‚åò+Enter' : 'Ctrl+Enter';
document.getElementById('btnRun').innerHTML = '‚ñ∂ Spustit <kbd>' + shortcutLabel + '</kbd>';
const rp = document.getElementById('resultsPlaceholder');
if (rp) rp.innerHTML = 'Napi≈° SQL dotaz a stiskni <kbd>' + shortcutText + '</kbd> pro spu≈°tƒõn√≠';

executeInstant(EXAMPLES[4].sql); // JOIN ON example
</script>
</body>
</html>